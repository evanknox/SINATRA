example(plot3d)
library(R.utils)
library(Rcpp)
library(Rvcg)
library(rgl)
library(pracma)
library(rgl)
library(knitr)
library(rgl)
library(FNN)
library(pracma)
library(Matrix)
library(Rcpp)
library(parallel)
library(Rvcg)
library(svd)
library(R.utils)
source("../athena_simulations/SINATRA_Code/ec_computation.R")
source("../athena_simulations/SINATRA_Code/generate_directions.R")
source("../athena_simulations/SINATRA_Code/RATEv2.R")
source("../athena_simulations/SINATRA_Code/shape_reconstruction.R")
source("../athena_simulations/SINATRA_Code/gp_inference.R")
source("../athena_simulations/SINATRA_Code/plotting_functions.R")
sourceCpp("../athena_simulations/SINATRA_Code/BAKRGibbs.cpp")
library(pdist)
desired_num_cones <- 15
cap_radius <- 0.10
directions_per_cone <- 4
### Generate directions ###
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
### Generate Data ###
nsim <- 30
curve_length <- 25
ball_radius <- 1.5
subdivision <- 3
cusps <- 50
### Create the Cusps on the sphere ###
regions =  generate_equidistributed_points(cusps,cusps)
#Initiate the causal points
sphere = vcgSphere(subdivision = subdivision)
region_vertex_dictionary <- vector("list",dim(regions)[1])
sphere_vertices <- asEuclidean(t(sphere$vb))
#get distances between regions and vertices
distances <- as.matrix(pdist::pdist(regions,sphere_vertices))
for (i in 1:(dim(sphere_vertices))[1]){
closest_region <- which.min(distances[,i])
region_vertex_dictionary[[closest_region]] <- c(region_vertex_dictionary[[closest_region]],i)
}
vertex_region_dictionary <- apply(distances,2,FUN = which.min)
causal_regions_1 <- c(1)
causal_regions_2 <- c(3)
shared_regions <- c(4)
### Get the causal and shared regions on the sphere ###
# iterate through class 1
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
total_closest_points_class1 = c(total_closest_points_class1,closest_points_class1)
total_cusps_list[[length(total_cusps_list) + 1]] = closest_points_class1
}
library(pdist)
desired_num_cones <- 15
cap_radius <- 0.10
directions_per_cone <- 4
### Generate directions ###
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
### Generate Data ###
nsim <- 30
curve_length <- 25
ball_radius <- 1.5
subdivision <- 3
cusps <- 50
### Create the Cusps on the sphere ###
regions =  generate_equidistributed_points(cusps,cusps)
#Initiate the causal points
sphere = vcgSphere(subdivision = subdivision)
region_vertex_dictionary <- vector("list",dim(regions)[1])
sphere_vertices <- asEuclidean(t(sphere$vb))
#get distances between regions and vertices
distances <- as.matrix(pdist::pdist(regions,sphere_vertices))
for (i in 1:(dim(sphere_vertices))[1]){
closest_region <- which.min(distances[,i])
region_vertex_dictionary[[closest_region]] <- c(region_vertex_dictionary[[closest_region]],i)
}
vertex_region_dictionary <- apply(distances,2,FUN = which.min)
causal_regions_1 <- c(1)
causal_regions_2 <- c(3)
shared_regions <- c(4)
causal_points <- 10
shared_points <- 10
### Get the causal and shared regions on the sphere ###
# iterate through class 1
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
total_closest_points_class1 = c(total_closest_points_class1,closest_points_class1)
total_cusps_list[[length(total_cusps_list) + 1]] = closest_points_class1
}
data <- matrix(NA,nrow=0,ncol = 1+curve_length*( dim(dir)[1]))
### Create the data ###
for (i in 1:nsim){
sphere1 = vcgSphere(subdivision = subdivision)
sphere2 = vcgSphere(subdivision = subdivision)
# Add noise to the sphere
sphere1$vb[1:3,] = sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
sphere2$vb[1:3,] = sphere2$vb[1:3,]  * rnorm(dim(sphere2$vb)[2], mean = 1, sd = 0.02)
# Elevate the causal regions - Needs to be changed
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 0.55 + rnorm(1, mean = 0, sd = 0.1)
}
for (j in 1:length(causal_regions_2)){
causal_dir2 = regions[causal_regions_2[j],]
closest_points_class2 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir2,ncol = 3), k = causal_points)
sphere2$vb[1:3,closest_points_class2] = sphere2$vb[1:3,closest_points_class2]  * 0.55 + rnorm(1, mean = 0, sd = 0.1)
}
# Elevate the shared regions - Needs to be changed
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere$vb[1:3,closest_points_shared]  * 1.35 + rnorm(1, mean = 0, sd = 0.1)
sphere1$vb[1:3,closest_points_shared] = shared_points
sphere2$vb[1:3,closest_points_shared] = shared_points
}
sphere_mesh1 = convert_off_file(sphere1)
sphere_mesh2 = convert_off_file(sphere2)
complex_points[[(2*i-1)]] = t(sphere1$vb[1:3,])
complex_points[[2*i]] = t(sphere2$vb[1:3,])
shared_points_list[[i]] = shared_points
ec_curve_class1 <- matrix(NA,nrow = 1,ncol=0)
ec_curve_class2 <- matrix(NA,nrow = 1,ncol=0)
### compute EC curves for both classes of curves
for (j in 1:dim(dir)[1]){
vertex_function_class_1 <- sphere_mesh1$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
vertex_function_class_2 <- sphere_mesh2$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
curve1 <- compute_standardized_ec_curve(sphere_mesh1, vertex_function_class_1, curve_length-1, first_column_index = FALSE,ball_radius)
curve2 <- compute_standardized_ec_curve(sphere_mesh2, vertex_function_class_2, curve_length-1, first_column_index = FALSE,ball_radius)
# transform the ECT as desired
curve1 <- update_ec_curve(curve1, ec_type)
curve2 <- update_ec_curve(curve2, ec_type)
# omit the length data, for now
ec_curve_class1 <- c(ec_curve_class1,curve1[,2])
ec_curve_class2 <- c(ec_curve_class2,curve2[,2])
}
data <- rbind(data,c(1,ec_curve_class1))
data <- rbind(data,c(-1,ec_curve_class2))
}
library(pdist)
desired_num_cones <- 15
cap_radius <- 0.10
directions_per_cone <- 4
### Generate directions ###
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
### Generate Data ###
nsim <- 30
curve_length <- 25
ball_radius <- 1.5
subdivision <- 3
cusps <- 50
### Create the Cusps on the sphere ###
regions =  generate_equidistributed_points(cusps,cusps)
#Initiate the causal points
sphere = vcgSphere(subdivision = subdivision)
region_vertex_dictionary <- vector("list",dim(regions)[1])
sphere_vertices <- asEuclidean(t(sphere$vb))
#get distances between regions and vertices
distances <- as.matrix(pdist::pdist(regions,sphere_vertices))
for (i in 1:(dim(sphere_vertices))[1]){
closest_region <- which.min(distances[,i])
region_vertex_dictionary[[closest_region]] <- c(region_vertex_dictionary[[closest_region]],i)
}
vertex_region_dictionary <- apply(distances,2,FUN = which.min)
causal_regions_1 <- c(1)
causal_regions_2 <- c(3)
shared_regions <- c(4)
causal_points <- 10
noise_points <- 10
### Get the causal and shared regions on the sphere ###
data <- matrix(NA,nrow=0,ncol = 1+curve_length*( dim(dir)[1]))
### Create the data ###
for (i in 1:nsim){
sphere1 = vcgSphere(subdivision = subdivision)
sphere2 = vcgSphere(subdivision = subdivision)
# Add noise to the sphere
sphere1$vb[1:3,] = sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
sphere2$vb[1:3,] = sphere2$vb[1:3,]  * rnorm(dim(sphere2$vb)[2], mean = 1, sd = 0.02)
# Elevate the causal regions - Needs to be changed
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 0.55 + rnorm(1, mean = 0, sd = 0.1)
}
for (j in 1:length(causal_regions_2)){
causal_dir2 = regions[causal_regions_2[j],]
closest_points_class2 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir2,ncol = 3), k = causal_points)
sphere2$vb[1:3,closest_points_class2] = sphere2$vb[1:3,closest_points_class2]  * 0.55 + rnorm(1, mean = 0, sd = 0.1)
}
# Elevate the shared regions - Needs to be changed
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere$vb[1:3,closest_points_shared]  * 1.35 + rnorm(1, mean = 0, sd = 0.1)
sphere1$vb[1:3,closest_points_shared] = shared_points
sphere2$vb[1:3,closest_points_shared] = shared_points
}
sphere_mesh1 = convert_off_file(sphere1)
sphere_mesh2 = convert_off_file(sphere2)
complex_points[[(2*i-1)]] = t(sphere1$vb[1:3,])
complex_points[[2*i]] = t(sphere2$vb[1:3,])
shared_points_list[[i]] = shared_points
ec_curve_class1 <- matrix(NA,nrow = 1,ncol=0)
ec_curve_class2 <- matrix(NA,nrow = 1,ncol=0)
### compute EC curves for both classes of curves
for (j in 1:dim(dir)[1]){
vertex_function_class_1 <- sphere_mesh1$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
vertex_function_class_2 <- sphere_mesh2$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
curve1 <- compute_standardized_ec_curve(sphere_mesh1, vertex_function_class_1, curve_length-1, first_column_index = FALSE,ball_radius)
curve2 <- compute_standardized_ec_curve(sphere_mesh2, vertex_function_class_2, curve_length-1, first_column_index = FALSE,ball_radius)
# transform the ECT as desired
curve1 <- update_ec_curve(curve1, ec_type)
curve2 <- update_ec_curve(curve2, ec_type)
# omit the length data, for now
ec_curve_class1 <- c(ec_curve_class1,curve1[,2])
ec_curve_class2 <- c(ec_curve_class2,curve2[,2])
}
data <- rbind(data,c(1,ec_curve_class1))
data <- rbind(data,c(-1,ec_curve_class2))
}
library(pdist)
desired_num_cones <- 15
cap_radius <- 0.10
directions_per_cone <- 4
### Generate directions ###
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
### Generate Data ###
nsim <- 30
curve_length <- 25
ball_radius <- 1.5
subdivision <- 3
cusps <- 50
### Create the Cusps on the sphere ###
regions =  generate_equidistributed_points(cusps,cusps)
#Initiate the causal points
sphere = vcgSphere(subdivision = subdivision)
region_vertex_dictionary <- vector("list",dim(regions)[1])
sphere_vertices <- asEuclidean(t(sphere$vb))
#get distances between regions and vertices
distances <- as.matrix(pdist::pdist(regions,sphere_vertices))
for (i in 1:(dim(sphere_vertices))[1]){
closest_region <- which.min(distances[,i])
region_vertex_dictionary[[closest_region]] <- c(region_vertex_dictionary[[closest_region]],i)
}
vertex_region_dictionary <- apply(distances,2,FUN = which.min)
causal_regions_1 <- c(1)
causal_regions_2 <- c(3)
shared_regions <- c(4)
causal_points <- 10
noise_points <- 10
### Get the causal and shared regions on the sphere ###
data <- matrix(NA,nrow=0,ncol = 1+curve_length*( dim(dir)[1]))
### Create the data ###
for (i in 1:nsim){
sphere1 = vcgSphere(subdivision = subdivision)
sphere2 = vcgSphere(subdivision = subdivision)
# Add noise to the sphere
sphere1$vb[1:3,] = sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
sphere2$vb[1:3,] = sphere2$vb[1:3,]  * rnorm(dim(sphere2$vb)[2], mean = 1, sd = 0.02)
# Elevate the causal regions - Needs to be changed
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 0.55 + rnorm(1, mean = 0, sd = 0.1)
}
for (j in 1:length(causal_regions_2)){
causal_dir2 = regions[causal_regions_2[j],]
closest_points_class2 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir2,ncol = 3), k = causal_points)
sphere2$vb[1:3,closest_points_class2] = sphere2$vb[1:3,closest_points_class2]  * 0.55 + rnorm(1, mean = 0, sd = 0.1)
}
# Elevate the shared regions - Needs to be changed
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere$vb[1:3,closest_points_shared]  * 1.35 + rnorm(1, mean = 0, sd = 0.1)
sphere1$vb[1:3,closest_points_shared] = shared_points
sphere2$vb[1:3,closest_points_shared] = shared_points
}
sphere_mesh1 = convert_off_file(sphere1)
sphere_mesh2 = convert_off_file(sphere2)
ec_curve_class1 <- matrix(NA,nrow = 1,ncol=0)
ec_curve_class2 <- matrix(NA,nrow = 1,ncol=0)
### compute EC curves for both classes of curves
for (j in 1:dim(dir)[1]){
vertex_function_class_1 <- sphere_mesh1$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
vertex_function_class_2 <- sphere_mesh2$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
curve1 <- compute_standardized_ec_curve(sphere_mesh1, vertex_function_class_1, curve_length-1, first_column_index = FALSE,ball_radius)
curve2 <- compute_standardized_ec_curve(sphere_mesh2, vertex_function_class_2, curve_length-1, first_column_index = FALSE,ball_radius)
# transform the ECT as desired
curve1 <- update_ec_curve(curve1, ec_type)
curve2 <- update_ec_curve(curve2, ec_type)
# omit the length data, for now
ec_curve_class1 <- c(ec_curve_class1,curve1[,2])
ec_curve_class2 <- c(ec_curve_class2,curve2[,2])
}
data <- rbind(data,c(1,ec_curve_class1))
data <- rbind(data,c(-1,ec_curve_class2))
}
library(pdist)
desired_num_cones <- 15
cap_radius <- 0.10
directions_per_cone <- 4
### Generate directions ###
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
### Generate Data ###
nsim <- 30
curve_length <- 25
ball_radius <- 1.5
subdivision <- 3
cusps <- 50
### Create the Cusps on the sphere ###
regions =  generate_equidistributed_points(cusps,cusps)
#Initiate the causal points
sphere = vcgSphere(subdivision = subdivision)
region_vertex_dictionary <- vector("list",dim(regions)[1])
sphere_vertices <- asEuclidean(t(sphere$vb))
#get distances between regions and vertices
distances <- as.matrix(pdist::pdist(regions,sphere_vertices))
for (i in 1:(dim(sphere_vertices))[1]){
closest_region <- which.min(distances[,i])
region_vertex_dictionary[[closest_region]] <- c(region_vertex_dictionary[[closest_region]],i)
}
vertex_region_dictionary <- apply(distances,2,FUN = which.min)
causal_regions_1 <- c(1)
causal_regions_2 <- c(3)
shared_regions <- c(4)
causal_points <- 10
noise_points <- 10
### Get the causal and shared regions on the sphere ###
data <- matrix(NA,nrow=0,ncol = 1+curve_length*( dim(dir)[1]))
### Create the data ###
for (i in 1:nsim){
sphere1 = vcgSphere(subdivision = subdivision)
sphere2 = vcgSphere(subdivision = subdivision)
# Add noise to the sphere
sphere1$vb[1:3,] = sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
sphere2$vb[1:3,] = sphere2$vb[1:3,]  * rnorm(dim(sphere2$vb)[2], mean = 1, sd = 0.02)
# Elevate the causal regions - Needs to be changed
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 0.55 + rnorm(1, mean = 0, sd = 0.1)
}
for (j in 1:length(causal_regions_2)){
causal_dir2 = regions[causal_regions_2[j],]
closest_points_class2 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir2,ncol = 3), k = causal_points)
sphere2$vb[1:3,closest_points_class2] = sphere2$vb[1:3,closest_points_class2]  * 0.55 + rnorm(1, mean = 0, sd = 0.1)
}
# Elevate the shared regions - Needs to be changed
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere$vb[1:3,closest_points_shared]  * 1.35 + rnorm(1, mean = 0, sd = 0.1)
sphere1$vb[1:3,closest_points_shared] = shared_points
sphere2$vb[1:3,closest_points_shared] = shared_points
}
sphere_mesh1 = convert_off_file(sphere1)
sphere_mesh2 = convert_off_file(sphere2)
ec_curve_class1 <- matrix(NA,nrow = 1,ncol=0)
ec_curve_class2 <- matrix(NA,nrow = 1,ncol=0)
### compute EC curves for both classes of curves
for (j in 1:dim(dir)[1]){
vertex_function_class_1 <- sphere_mesh1$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
vertex_function_class_2 <- sphere_mesh2$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
curve1 <- compute_standardized_ec_curve(sphere_mesh1, vertex_function_class_1, curve_length-1, first_column_index = FALSE,ball_radius)
curve2 <- compute_standardized_ec_curve(sphere_mesh2, vertex_function_class_2, curve_length-1, first_column_index = FALSE,ball_radius)
# transform the ECT as desired
curve1 <- update_ec_curve(curve1, ec_type)
curve2 <- update_ec_curve(curve2, ec_type)
# omit the length data, for now
ec_curve_class1 <- c(ec_curve_class1,curve1[,2])
ec_curve_class2 <- c(ec_curve_class2,curve2[,2])
}
data <- rbind(data,c(1,ec_curve_class1))
data <- rbind(data,c(-1,ec_curve_class2))
}
rm(list = ls(all = TRUE))
desired_num_cones <- 50
cap_radius <- 0.10
directions_per_cone <- 4
### Generate directions ###
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
library(pdist)
desired_num_cones <- 50
cap_radius <- 0.10
directions_per_cone <- 4
### Generate directions ###
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
library(knitr)
library(rgl)
library(FNN)
library(pracma)
library(Matrix)
library(Rcpp)
library(parallel)
library(Rvcg)
library(svd)
library(R.utils)
source("../athena_simulations/SINATRA_Code/ec_computation.R")
source("../athena_simulations/SINATRA_Code/generate_directions.R")
source("../athena_simulations/SINATRA_Code/RATEv2.R")
source("../athena_simulations/SINATRA_Code/shape_reconstruction.R")
source("../athena_simulations/SINATRA_Code/gp_inference.R")
source("../athena_simulations/SINATRA_Code/plotting_functions.R")
sourceCpp("../athena_simulations/SINATRA_Code/BAKRGibbs.cpp")
library(pdist)
desired_num_cones <- 50
cap_radius <- 0.10
directions_per_cone <- 4
### Generate directions ###
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
### Generate Data ###
cusps <- 50
### Create the Cusps on the sphere ###
regions =  generate_equidistributed_points(cusps,cusps)
#Initiate the causal points
sphere = vcgSphere(subdivision = subdivision)
desired_num_cones <- 15
cap_radius <- 0.1
directions_per_cone <- 4
### Generate directions ###
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
### Generate Data ###
nsim <- 50
curve_length <- 20
ball_radius <- 1.5
subdivision <- 3
ec_type <- 'ECT'
library(pdist)
desired_num_cones <- 50
cap_radius <- 0.10
directions_per_cone <- 4
### Generate directions ###
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
### Generate Data ###
cusps <- 50
### Create the Cusps on the sphere ###
regions =  generate_equidistributed_points(cusps,cusps)
#Initiate the causal points
sphere = vcgSphere(subdivision = subdivision)
region_vertex_dictionary <- vector("list",dim(regions)[1])
sphere_vertices <- asEuclidean(t(sphere$vb))
#get distances between regions and vertices
distances <- as.matrix(pdist::pdist(regions,sphere_vertices))
library(RATE)
set.seed(4913, kind = "L'Ecuyer-CMRG")
library(sinatra)
library(FNN)
library(rgl)
library(Rvcg)
library(plyr)
library(pdist)
library(gglasso)
library(numbers)
library(data.table)
cap_radius = 0.15
num_cones = 5
directions_per_cone = 5
len = 75
num_causal_region = 2
num_shared_region = 1
causal_points = 10
shared_points = 10
subdivision = 3
View(generate_data_sphere_simulation_new)
library(sinatra)
cap_radius = 0.15
num_cones = 5
directions_per_cone = 5
len = 75
num_causal_region = 2
num_shared_region = 1
causal_points = 10
shared_points = 10
subdivision = 3
nsim = 25
cusps = 50
causal_dirs = generate_equidistributed_points(cusps, cusps +1)
causal_regions_1 = sample(1:cusps,num_causal_region)
causal_regions_2 = sample((1:cusps)[-causal_regions_1],num_causal_region)
shared_regions = sample((1:cusps)[-c(causal_regions_1,causal_regions_2)],num_shared_region)
#### Fig 2.a. ####
g1 = generate_averaged_ROC_with_coned_directions(runs = 5, nsim = 50, curve_length = 30, grid_size = 25, distance_to_causal_point = 0.1,
causal_points = causal_points,shared_points = shared_points, num_cones = 20, eta = 0.1,
truncated = 200, two_curves = TRUE, ball = TRUE, ball_radius = 1.5, type = 'vertex',
min_points = 3, directions_per_cone = 5, cap_radius = 0.15, radius = 1,ec_type = 'ECT',
mode = 'sphere_baseline',num_cusps = cusps,
subdivision = 3,num_causal_region = num_causal_region, num_shared_region = num_shared_region)
#### Fig 2.a. ####
g1 = generate_averaged_ROC_with_coned_directions(runs = 5, nsim = 50, curve_length = 30, grid_size = 25, distance_to_causal_point = 0.1,
causal_points = causal_points,shared_points = shared_points, num_cones = 20, eta = 0.1,
truncated = 200, two_curves = TRUE, ball = TRUE, ball_radius = 1.5, type = 'vertex',
min_points = 3, directions_per_cone = 5, cap_radius = 0.15, radius = 1,ec_type = 'ECT',
mode = 'sphere_baseline',
subdivision = 3,num_causal_region = num_causal_region, num_shared_region = num_shared_region)
detach("package:sinatra", unload = TRUE)
build()
library(devtools)
build()
setwd("~/projects/Research/SINATRA/sinatra")
build()
install.packages("glmnet")
install.packages("installr")
