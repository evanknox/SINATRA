# Add noise to the sphere
sphere1$vb[1:3,] = sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
sphere2$vb[1:3,] = sphere2$vb[1:3,]  * rnorm(dim(sphere2$vb)[2], mean = 1, sd = 0.02)
# Elevate the causal regions - Needs to be changed
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 1.55 + rnorm(1, mean = 0, sd = 0.1)
}
for (j in 1:length(causal_regions_2)){
causal_dir2 = regions[causal_regions_2[j],]
closest_points_class2 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir2,ncol = 3), k = causal_points)
sphere2$vb[1:3,closest_points_class2] = sphere2$vb[1:3,closest_points_class2]  * 1.55 + rnorm(1, mean = 0, sd = 0.1)
}
# Elevate the shared regions - Needs to be changed
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere$vb[1:3,closest_points_shared]  * 0.55 + rnorm(1, mean = 0, sd = 0.1)
sphere1$vb[1:3,closest_points_shared] = shared_points
sphere2$vb[1:3,closest_points_shared] = shared_points
}
sphere_mesh1 = convert_off_file(sphere1)
sphere_mesh2 = convert_off_file(sphere2)
ec_curve_class1 <- matrix(NA,nrow = 1,ncol=0)
ec_curve_class2 <- matrix(NA,nrow = 1,ncol=0)
### compute EC curves for both classes of curves
for (j in 1:dim(dir)[1]){
vertex_function_class_1 <- sphere_mesh1$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
vertex_function_class_2 <- sphere_mesh2$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
curve1 <- compute_standardized_ec_curve(sphere_mesh1, vertex_function_class_1, curve_length-1, first_column_index = FALSE,ball_radius)
curve2 <- compute_standardized_ec_curve(sphere_mesh2, vertex_function_class_2, curve_length-1, first_column_index = FALSE,ball_radius)
# transform the ECT as desired
curve1 <- update_ec_curve(curve1, ec_type)
curve2 <- update_ec_curve(curve2, ec_type)
# omit the length data, for now
ec_curve_class1 <- c(ec_curve_class1,curve1[,2])
ec_curve_class2 <- c(ec_curve_class2,curve2[,2])
}
data <- rbind(data,c(1,ec_curve_class1))
data <- rbind(data,c(-1,ec_curve_class2))
}
rate_values_sim <- find_rate_variables_with_other_sampling_methods(data, bandwidth = 0.1, type = 'ESS')[,2]
hist(rate_values_sim,100)
sphere1 <- vcgSphere(subdivision = subdivision)
sphere1$vb[1:3,] <- sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 1.55
}
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere1$vb[1:3,closest_points_shared]  * 0.55
sphere1$vb[1:3,closest_points_shared] = shared_points
}
sphere1
sphere1$vb
dim(sphere1)
dim(sphere1$vb)
sample(1:100,10)
matrix(0,nrow = 1, ncol = 10)
cuts <-length(rate_values_sim)
vert_matrix1 <- reconstruct_vertices_on_shape(dir, complex1, rate_values_sim, curve_length, cuts = length(rate_values_sim),
directions_per_cone, ball_radius, TRUE)
vert_matrix1
hist(vert_matrix1,20)
hist(vert_matrix1[,1],20)
complex <- sphere1
vertex <- 40
region_size <- 5
# compute region size
region <- knnx.index(data = t(complex$vb[-4,]),query = vertex, k = region_size)
vertex
complex$vb[-4,]
# compute region size
region <- knnx.index(data = t(complex$vb[-4,]),query = complex$vb[-4,vertex], k = region_size)
# compute region size
region <- knnx.index(data = t(complex$vb[-4,]),query = t(complex$vb[-4,vertex]), k = region_size)
region
mesh_fcn <- vert_matrix1[,2]
mesh_fcn[40]
mesh_fcn[c(40,30)]
mesh_fcn[region]
sum(mesh_fcn[region])
complex <- sphere1
vertex <- 40
region_size <- 10
num_test_regions <- 100
# compute region size
region <- knnx.index(data = t(complex$vb[-4,]),query = t(complex$vb[-4,vertex]), k = region_size)
region_val <- sum(mesh_fcn[region])
region_val
# select random regions
random_regions <- sample(1:dim(complex$vb)[2], num_test_regions)
random_region_vals <- matrix(0,nrow = 1, ncol = num_test_regions)
for(i in 1:num_test_regions){
random_region_vals[i] <- sum(mesh_fcn[random_region_vals])
}
return(c(region_val,random_region_vals))
c(region_val,random_region_vals)
# select random regions
random_regions <- sample(1:dim(complex$vb)[2], num_test_regions)
random_region_vals <- matrix(0,nrow = 1, ncol = num_test_regions)
for(i in 1:num_test_regions){
random_vertex <- random_regions[i]
random_region <- knnx.index(data = t(complex$vb[-4,]),query = t(complex$vb[-4,random_vertex]), k = region_size)
random_region_vals[i] <- sum(mesh_fcn[random_region])
}
c(region_val,random_region_vals)
histogram(c(region_val,random_region_vals))
hist(c(region_val,random_region_vals))
sphere1
vertex <- 1
compute_differential_evidence <- function(sphere1, mesh_fcn, vertex, 10, 100)
compute_differential_evidence(sphere1, mesh_fcn, vertex, 10, 100)
#' @export
#'
#' @param mesh mesh3d object.
#' @param mesh_fcn (2 x M vector) the values of the function on the vertices of the mesh.
#' @param vertex (int) the index of the desired vertex to analyze on the mesh
#' @param region_size (int) the number of vertices to be in the region. We choose the region via knn. The assumption is that the
#'  density if vertices in the mesh is uniform, or at least approximately.
#' @param num_test_regions (int) the number of regions to sample from
#'
#' @return sum of function values for the input region, and a vector of length N of the sum of function values for the random test regions
compute_differential_evidence <- function(complex, mesh_fcn, vertex, region_size, num_test_regions){
# compute region size
region <- knnx.index(data = t(complex$vb[-4,]),query = t(complex$vb[-4,vertex]), k = region_size)
region_val <- sum(mesh_fcn[region])
# select random regions
random_regions <- sample(1:dim(complex$vb)[2], num_test_regions)
random_region_vals <- matrix(0,nrow = 1, ncol = num_test_regions)
for(i in 1:num_test_regions){
random_vertex <- random_regions[i]
random_region <- knnx.index(data = t(complex$vb[-4,]),query = t(complex$vb[-4,random_vertex]), k = region_size)
random_region_vals[i] <- sum(mesh_fcn[random_region])
}
return(c(region_val,random_region_vals))
}
compute_differential_evidence(sphere1, mesh_fcn, vertex, 10, 100)
hist(sphere1)
x <- compute_differential_evidence(sphere1, mesh_fcn, vertex, 10, 100)
hist(x)
abline(h = 1.384087e-04)
abline(v = 1.384087e-04)
hist(x)
abline(v = 1.384087e-04)
x
x <- compute_differential_evidence(sphere1, mesh_fcn, vertex, 5, 1000)
x <- compute_differential_evidence(sphere1, mesh_fcn, vertex, 5, 500)
x
vertex
hist(x)
abline(v = x[1], color = 'red')
abline(v = x[1], col = 'red')
x <- compute_differential_evidence(sphere1, mesh_fcn, 15, 5, 500)
hist(x)
abline(v = x[1], col = 'red')
desired_num_cones <- 50
cap_radius <- 0.10
directions_per_cone <- 5
nsim <- 10 # number of shapes in the data set to generate
curve_length <- 30
ball_radius <- 1.5
ec_type <- 'ECT'
# generate the set of directions to on which measure EC
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
cusps <- 50
subdivision <- 3 # granularity of the generated shape
### Create the Cusps on the sphere ###
regions =  generate_equidistributed_points(cusps,cusps)
#Initiate the causal points
sphere = vcgSphere(subdivision = subdivision)
region_vertex_dictionary <- vector("list",dim(regions)[1])
sphere_vertices <- asEuclidean(t(sphere$vb))
#get distances between regions and vertices
distances <- as.matrix(pdist::pdist(regions,sphere_vertices))
for (i in 1:(dim(sphere_vertices))[1]){
closest_region <- which.min(distances[,i])
region_vertex_dictionary[[closest_region]] <- c(region_vertex_dictionary[[closest_region]],i)
}
vertex_region_dictionary <- apply(distances,2,FUN = which.min)
causal_regions_1 <- c(1,15)
causal_regions_2 <- c(50,40)
shared_regions <- c(25,10,30,35)
# set the size of the causal / shared regions.
causal_points <- 10
noise_points <- 10
data <- matrix(NA,nrow=0,ncol = 1+curve_length*( dim(dir)[1]))
for (i in 1:nsim){
sphere1 = vcgSphere(subdivision = subdivision)
sphere2 = vcgSphere(subdivision = subdivision)
# Add noise to the sphere
sphere1$vb[1:3,] = sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
sphere2$vb[1:3,] = sphere2$vb[1:3,]  * rnorm(dim(sphere2$vb)[2], mean = 1, sd = 0.02)
# Elevate the causal regions - Needs to be changed
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 1.55 + rnorm(1, mean = 0, sd = 0.1)
}
for (j in 1:length(causal_regions_2)){
causal_dir2 = regions[causal_regions_2[j],]
closest_points_class2 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir2,ncol = 3), k = causal_points)
sphere2$vb[1:3,closest_points_class2] = sphere2$vb[1:3,closest_points_class2]  * 1.55 + rnorm(1, mean = 0, sd = 0.1)
}
# Elevate the shared regions - Needs to be changed
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere$vb[1:3,closest_points_shared]  * 0.55 + rnorm(1, mean = 0, sd = 0.1)
sphere1$vb[1:3,closest_points_shared] = shared_points
sphere2$vb[1:3,closest_points_shared] = shared_points
}
sphere_mesh1 = convert_off_file(sphere1)
sphere_mesh2 = convert_off_file(sphere2)
ec_curve_class1 <- matrix(NA,nrow = 1,ncol=0)
ec_curve_class2 <- matrix(NA,nrow = 1,ncol=0)
### compute EC curves for both classes of curves
for (j in 1:dim(dir)[1]){
vertex_function_class_1 <- sphere_mesh1$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
vertex_function_class_2 <- sphere_mesh2$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
curve1 <- compute_standardized_ec_curve(sphere_mesh1, vertex_function_class_1, curve_length-1, first_column_index = FALSE,ball_radius)
curve2 <- compute_standardized_ec_curve(sphere_mesh2, vertex_function_class_2, curve_length-1, first_column_index = FALSE,ball_radius)
# transform the ECT as desired
curve1 <- update_ec_curve(curve1, ec_type)
curve2 <- update_ec_curve(curve2, ec_type)
# omit the length data, for now
ec_curve_class1 <- c(ec_curve_class1,curve1[,2])
ec_curve_class2 <- c(ec_curve_class2,curve2[,2])
}
data <- rbind(data,c(1,ec_curve_class1))
data <- rbind(data,c(-1,ec_curve_class2))
}
rate_values_sim <- find_rate_variables_with_other_sampling_methods(data, bandwidth = 0.1, type = 'ESS')[,2]
sphere1 <- vcgSphere(subdivision = subdivision)
sphere1$vb[1:3,] <- sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 1.55
}
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere1$vb[1:3,closest_points_shared]  * 0.55
sphere1$vb[1:3,closest_points_shared] = shared_points
}
complex1<- convert_off_file(sphere1)
cuts <-length(rate_values_sim)
vert_matrix1 <- reconstruct_vertices_on_shape(dir, complex1, rate_values_sim, curve_length, cuts = length(rate_values_sim),
directions_per_cone, ball_radius, TRUE)
x <- compute_differential_evidence(sphere1, mesh_fcn, 15, 5, 500)
hist(x)
abline(v = x[1], col = 'red')
x <- compute_differential_evidence(sphere1, mesh_fcn, 50, 5, 500)
hist(x)
abline(v = x[1], col = 'red')
x <- compute_differential_evidence(sphere1, mesh_fcn, 40, 5, 500)
hist(x)
abline(v = x[1], col = 'red')
x <- compute_differential_evidence(sphere1, vert_matrix1[1,], 40, 5, 500)
hist(x)
x <- compute_differential_evidence(sphere1, vert_matrix1[,1], 40, 5, 500)
hist(x)
abline(v = x[1], col = 'red')
x <- compute_differential_evidence(sphere1, vert_matrix1[,2], 40, 5, 500)
hist(x)
abline(v = x[1], col = 'red')
x <- compute_differential_evidence(sphere1, vert_matrix1[,2], 1, 5, 500)
hist(x)
abline(v = x[1], col = 'red')
x <- compute_differential_evidence(sphere1, vert_matrix1[,2], 15, 5, 500)
hist(x)
abline(v = x[1], col = 'red')
color1='blue'
color2='lightgreen'
color3='orangered'
color3 = 'red'
col_pal=c(color1,color2,color2,color3)
colfunc <- colorRampPalette(col_pal)
# plot, using absolute birth times
vert_heat1 <- colfunc(cuts)[vert_matrix1[,1]] #absolute
#vert_heat1 = colfunc(1 + max(vert_matrix1[,1]) - min(vert_matrix1[,1]))[1 + vert_matrix1[,1] - min(vert_matrix1[,1])] # relative
plot3d(sphere1, col = vert_heat1, back="lines", specular="white", axes = FALSE,xlab = '', ylab = '',zlab='')
desired_num_cones <- 50
cap_radius <- 0.15
directions_per_cone <- 7
nsim <- 30 # number of shapes in the data set to generate
curve_length <- 30
ball_radius <- 1.5
ec_type <- 'ECT'
# generate the set of directions to on which measure EC
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
cusps <- 50
subdivision <- 3 # granularity of the generated shape
### Create the Cusps on the sphere ###
regions =  generate_equidistributed_points(cusps,cusps)
#Initiate the causal points
sphere = vcgSphere(subdivision = subdivision)
region_vertex_dictionary <- vector("list",dim(regions)[1])
sphere_vertices <- asEuclidean(t(sphere$vb))
#get distances between regions and vertices
distances <- as.matrix(pdist::pdist(regions,sphere_vertices))
for (i in 1:(dim(sphere_vertices))[1]){
closest_region <- which.min(distances[,i])
region_vertex_dictionary[[closest_region]] <- c(region_vertex_dictionary[[closest_region]],i)
}
vertex_region_dictionary <- apply(distances,2,FUN = which.min)
causal_regions_1 <- c(1,15)
causal_regions_2 <- c(50,40)
shared_regions <- c(25,10,30,35)
# set the size of the causal / shared regions.
causal_points <- 10
noise_points <- 10
data <- matrix(NA,nrow=0,ncol = 1+curve_length*( dim(dir)[1]))
for (i in 1:nsim){
sphere1 = vcgSphere(subdivision = subdivision)
sphere2 = vcgSphere(subdivision = subdivision)
# Add noise to the sphere
sphere1$vb[1:3,] = sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
sphere2$vb[1:3,] = sphere2$vb[1:3,]  * rnorm(dim(sphere2$vb)[2], mean = 1, sd = 0.02)
# Elevate the causal regions - Needs to be changed
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 1.55 + rnorm(1, mean = 0, sd = 0.1)
}
for (j in 1:length(causal_regions_2)){
causal_dir2 = regions[causal_regions_2[j],]
closest_points_class2 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir2,ncol = 3), k = causal_points)
sphere2$vb[1:3,closest_points_class2] = sphere2$vb[1:3,closest_points_class2]  * 1.55 + rnorm(1, mean = 0, sd = 0.1)
}
# Elevate the shared regions - Needs to be changed
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere$vb[1:3,closest_points_shared]  * 0.55 + rnorm(1, mean = 0, sd = 0.1)
sphere1$vb[1:3,closest_points_shared] = shared_points
sphere2$vb[1:3,closest_points_shared] = shared_points
}
sphere_mesh1 = convert_off_file(sphere1)
sphere_mesh2 = convert_off_file(sphere2)
ec_curve_class1 <- matrix(NA,nrow = 1,ncol=0)
ec_curve_class2 <- matrix(NA,nrow = 1,ncol=0)
### compute EC curves for both classes of curves
for (j in 1:dim(dir)[1]){
vertex_function_class_1 <- sphere_mesh1$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
vertex_function_class_2 <- sphere_mesh2$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
curve1 <- compute_standardized_ec_curve(sphere_mesh1, vertex_function_class_1, curve_length-1, first_column_index = FALSE,ball_radius)
curve2 <- compute_standardized_ec_curve(sphere_mesh2, vertex_function_class_2, curve_length-1, first_column_index = FALSE,ball_radius)
# transform the ECT as desired
curve1 <- update_ec_curve(curve1, ec_type)
curve2 <- update_ec_curve(curve2, ec_type)
# omit the length data, for now
ec_curve_class1 <- c(ec_curve_class1,curve1[,2])
ec_curve_class2 <- c(ec_curve_class2,curve2[,2])
}
data <- rbind(data,c(1,ec_curve_class1))
data <- rbind(data,c(-1,ec_curve_class2))
}
rate_values_sim <- find_rate_variables_with_other_sampling_methods(data, bandwidth = 0.1, type = 'ESS')[,2]
sphere1 <- vcgSphere(subdivision = subdivision)
sphere1$vb[1:3,] <- sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 1.55
}
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere1$vb[1:3,closest_points_shared]  * 0.55
sphere1$vb[1:3,closest_points_shared] = shared_points
}
complex1<- convert_off_file(sphere1)
cuts <-length(rate_values_sim)
vert_matrix1 <- reconstruct_vertices_on_shape(dir, complex1, rate_values_sim, curve_length, cuts = length(rate_values_sim),
directions_per_cone, ball_radius, TRUE)
desired_num_cones <- 20
cap_radius <- 0.15
directions_per_cone <- 5
nsim <- 15 # number of shapes in the data set to generate
curve_length <- 25
ball_radius <- 1.5
ec_type <- 'ECT'
# generate the set of directions to on which measure EC
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
cusps <- 50
subdivision <- 3 # granularity of the generated shape
### Create the Cusps on the sphere ###
regions =  generate_equidistributed_points(cusps,cusps)
#Initiate the causal points
sphere = vcgSphere(subdivision = subdivision)
region_vertex_dictionary <- vector("list",dim(regions)[1])
sphere_vertices <- asEuclidean(t(sphere$vb))
#get distances between regions and vertices
distances <- as.matrix(pdist::pdist(regions,sphere_vertices))
for (i in 1:(dim(sphere_vertices))[1]){
closest_region <- which.min(distances[,i])
region_vertex_dictionary[[closest_region]] <- c(region_vertex_dictionary[[closest_region]],i)
}
vertex_region_dictionary <- apply(distances,2,FUN = which.min)
causal_regions_1 <- c(1)
causal_regions_2 <- c(40)
shared_regions <- c(25,10)
# set the size of the causal / shared regions.
causal_points <- 10
noise_points <- 10
data <- matrix(NA,nrow=0,ncol = 1+curve_length*( dim(dir)[1]))
for (i in 1:nsim){
sphere1 = vcgSphere(subdivision = subdivision)
sphere2 = vcgSphere(subdivision = subdivision)
# Add noise to the sphere
sphere1$vb[1:3,] = sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
sphere2$vb[1:3,] = sphere2$vb[1:3,]  * rnorm(dim(sphere2$vb)[2], mean = 1, sd = 0.02)
# Elevate the causal regions - Needs to be changed
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 1.55 + rnorm(1, mean = 0, sd = 0.1)
}
for (j in 1:length(causal_regions_2)){
causal_dir2 = regions[causal_regions_2[j],]
closest_points_class2 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir2,ncol = 3), k = causal_points)
sphere2$vb[1:3,closest_points_class2] = sphere2$vb[1:3,closest_points_class2]  * 1.55 + rnorm(1, mean = 0, sd = 0.1)
}
# Elevate the shared regions - Needs to be changed
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere$vb[1:3,closest_points_shared]  * 0.55 + rnorm(1, mean = 0, sd = 0.1)
sphere1$vb[1:3,closest_points_shared] = shared_points
sphere2$vb[1:3,closest_points_shared] = shared_points
}
sphere_mesh1 = convert_off_file(sphere1)
sphere_mesh2 = convert_off_file(sphere2)
ec_curve_class1 <- matrix(NA,nrow = 1,ncol=0)
ec_curve_class2 <- matrix(NA,nrow = 1,ncol=0)
### compute EC curves for both classes of curves
for (j in 1:dim(dir)[1]){
vertex_function_class_1 <- sphere_mesh1$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
vertex_function_class_2 <- sphere_mesh2$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
curve1 <- compute_standardized_ec_curve(sphere_mesh1, vertex_function_class_1, curve_length-1, first_column_index = FALSE,ball_radius)
curve2 <- compute_standardized_ec_curve(sphere_mesh2, vertex_function_class_2, curve_length-1, first_column_index = FALSE,ball_radius)
# transform the ECT as desired
curve1 <- update_ec_curve(curve1, ec_type)
curve2 <- update_ec_curve(curve2, ec_type)
# omit the length data, for now
ec_curve_class1 <- c(ec_curve_class1,curve1[,2])
ec_curve_class2 <- c(ec_curve_class2,curve2[,2])
}
data <- rbind(data,c(1,ec_curve_class1))
data <- rbind(data,c(-1,ec_curve_class2))
}
rate_values_sim <- find_rate_variables_with_other_sampling_methods(data, bandwidth = 0.1, type = 'ESS')[,2]
sphere1 <- vcgSphere(subdivision = subdivision)
sphere1$vb[1:3,] <- sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 1.55
}
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere1$vb[1:3,closest_points_shared]  * 0.55
sphere1$vb[1:3,closest_points_shared] = shared_points
}
complex1<- convert_off_file(sphere1)
cuts <-length(rate_values_sim)
vert_matrix1 <- reconstruct_vertices_on_shape(dir, complex1, rate_values_sim, curve_length, cuts = length(rate_values_sim),
directions_per_cone, ball_radius, TRUE)
color1='blue'
color2='lightgreen'
color3='orangered'
color3 = 'red'
col_pal=c(color1,color2,color2,color3)
colfunc <- colorRampPalette(col_pal)
# plot, using absolute birth times
vert_heat1 <- colfunc(cuts)[vert_matrix1[,1]] #absolute
#vert_heat1 = colfunc(1 + max(vert_matrix1[,1]) - min(vert_matrix1[,1]))[1 + vert_matrix1[,1] - min(vert_matrix1[,1])] # relative
plot3d(sphere1, col = vert_heat1, back="lines", specular="white", axes = FALSE,xlab = '', ylab = '',zlab='')
x <- compute_differential_evidence(sphere1, vert_matrix1[,2], 15, 1, 500)
hist(x)
abline(v = x[1], col = 'red')
x <- compute_differential_evidence(sphere1, vert_heat1, 15, 1, 500)
hist(x)
abline(v = x[1], col = 'red')
x <- compute_differential_evidence(sphere1, mesh_fcn, 15, 5, 500)
vert_heat1
vert_matrix1[,1]
x <- compute_differential_evidence(sphere1, vert_matrix1[,1], 15, 1, 500)
hist(x)
abline(v = x[1], col = 'red')
test_that("ROC Generation Works", {
expect_error(generate_ROC_with_coned_directions(nsim = 10, curve_length = 30, grid_size = 25, distance_to_causal_point = 0.1,
causal_points = causal_points,shared_points = shared_points, desired_num_cones = j, eta = 0.1,
truncated = 250, two_curves = TRUE, ball = TRUE, ball_radius = 1.5, type = 'vertex',
min_points = 3, directions_per_cone = 5, cap_radius = 0.15, radius = 1,ec_type = 'ECT',
mode = 'sphere', fpr = 0.05, start = 1, cusps = 50,
subdivision = 3,num_causal_region = num_causal_region, num_shared_region = num_shared_region), NA)
})
test_package()
library(testthat)
test_package()
test_package("sinatra")
devtools::test()
setwd("~/projects/Research/SINATRA/sinatra")
devtools::test()
