devtools::use_rcpp()
usethis::use_rcpp()
usethis::use_rcpp_armadillo()
setwd("~/projects/Research/SINATRA/sinatra/src")
install.packages("roxygen2")
setwd("~/projects/Research/SINATRA/sinatra/src")
pkgbuild::compile_dll()
devtools::document()
desired_num_cones <- 30
cap_radius <- 0.005
directions_per_cone <- 5
### Generate directions ###
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
### Generate Data ###
library(sinatra)
### Generate directions ###
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
setwd("~/projects/Research/SINATRA")
install('sinatra')
devtools::install('sinatra')
desired_num_cones <- 30
cap_radius <- 0.005
directions_per_cone <- 5
### Generate directions ###
dir <- generate_equidistributed_cones(desired_num_cones,cap_radius,directions_per_cone)
nsim <- 10
curve_length <- 25
ball_radius <- 2.5
subdivision <- 4
data <- matrix(NA,nrow=0,ncol = 1+curve_length*( dim(dir)[1]))
for (i in 1:nsim){
sphere1 = vcgSphere(subdivision = subdivision)
sphere2 = vcgSphere(subdivision = subdivision)
num_v <- (dim(sphere1$vb)[2])
# Add noise to the sphere
sphere2$vb[1:3,] = sphere2$vb[1:3,]  * rnorm(num_v, mean = 1, sd = 0.01)
# draw a parabola on the sphere
# find closest k points to (0,0,1) on the sphere
# scale by distance away from the point
sphere1$vb[1:3,] = sphere1$vb[1:3,] * rnorm(num_v, mean = 1, sd = 0.01)
for (i in 1:num_v){
#computes the 2D euclidean distance on the grid between the points
dist1 = difference(dir[1,], sphere1$vb[1:3,i])
if (dist1 < 0.2){
sphere1$vb[1:3,i] <- sphere1$vb[1:3,i]*((1 + 10*(0.2 - dist1)))^0.5
}
}
sphere_mesh1 = convert_off_file(sphere1)
sphere_mesh2 = convert_off_file(sphere2)
ec_curve_class1 <- matrix(NA,nrow = 1,ncol=0)
ec_curve_class2 <- matrix(NA,nrow = 1,ncol=0)
### compute EC curves for both classes of curves
for (j in 1:dim(dir)[1]){
vertex_function_class_1 <- sphere_mesh1$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
vertex_function_class_2 <- sphere_mesh2$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
curve1 <- compute_standardized_ec_curve(sphere_mesh1, vertex_function_class_1, curve_length-1, first_column_index = FALSE,ball_radius)
curve2 <- compute_standardized_ec_curve(sphere_mesh2, vertex_function_class_2, curve_length-1, first_column_index = FALSE,ball_radius)
# transform the ECT as desired
curve1 <- update_ec_curve(curve1, "DECT")
curve2 <- update_ec_curve(curve2, "DECT")
# omit the length data, for now
ec_curve_class1 <- c(ec_curve_class1,curve1[,2])
ec_curve_class2 <- c(ec_curve_class2,curve2[,2])
}
data <- rbind(data,c(1,ec_curve_class1))
data <- rbind(data,c(0,ec_curve_class2))
}
### Run the model + select features with RATE
# how does bandwidth impact reconstruction?
rate_values <- find_rate_variables_with_other_sampling_methods(data, bandwidth = 0.01, type = 'EP')[,2]
devtools::use_rcpp()
devtools::use_rcpp()
devtools::use_rcpp()
usethis::use_rcpp_armadillo()
pkgbuild::compile_dll()
devtools::document()
setwd("~/projects/Research/SINATRA/sinatra")
pkgbuild::compile_dll()
devtools::document()
pkgbuild::compile_dll()
devtools::document()
pkgbuild::compile_dll()
devtools::document()
pkgbuild::compile_dll()
pkgbuild::compile_dll()
### Clear Environment ###
rm(list = ls(all = TRUE))
### Clear Console ###
cat("\014")
source("SINATRA_Code/ec_computation.R")
source("SINATRA_Code/generate_directions.R")
source("SINATRA_Code/gp_inference.R")
source("SINATRA_Code/metric_curve_simulation.R")
source("SINATRA_Code/plotting_functions.R")
source("SINATRA_Code/roc_curve_simulation.R")
source("SINATRA_Code/shape_reconstruction.R")
source("SINATRA_Code/simulated_data_generation.R")
source("SINATRA_Code/RATEv2.R")
sourceCpp("SINATRA_Code/BAKRGibbs.cpp")
### Set the parameters for the analysis ###
set.seed(4913, kind = "L'Ecuyer-CMRG")
setwd("~/projects/Research/SINATRA/athena_simulations")
### Load in the R Libraries ###
library(truncnorm)
library(doParallel)
library(svd)
library(numbers)
### Load SINATRA functions ###
source("SINATRA_Code/ec_computation.R")
source("SINATRA_Code/generate_directions.R")
source("SINATRA_Code/gp_inference.R")
source("SINATRA_Code/metric_curve_simulation.R")
source("SINATRA_Code/plotting_functions.R")
source("SINATRA_Code/roc_curve_simulation.R")
source("SINATRA_Code/shape_reconstruction.R")
source("SINATRA_Code/simulated_data_generation.R")
source("SINATRA_Code/RATEv2.R")
sourceCpp("SINATRA_Code/BAKRGibbs.cpp")
arguments <- c(25,25,5,10)
arguments <- as.numeric(arguments)
nsim <- arguments[1]
num_cones <- arguments[2]
directions_per_cone <- arguments[3]
curve_length <- arguments[4]
cap_radius <- 0.15
### Generate directions ###
dir <- generate_equidistributed_cones(num_cones,cap_radius,directions_per_cone)
cusps <- 50
subdivision <- 3
ball_radius <- 1.5
### Create the Cusps on the sphere ###
regions =  generate_equidistributed_points(cusps,cusps)
#Initiate the causal points
sphere = vcgSphere(subdivision = subdivision)
region_vertex_dictionary <- vector("list",dim(regions)[1])
sphere_vertices <- asEuclidean(t(sphere$vb))
#get distances between regions and vertices
distances <- as.matrix(pdist::pdist(regions,sphere_vertices))
for (i in 1:(dim(sphere_vertices))[1]){
closest_region <- which.min(distances[,i])
region_vertex_dictionary[[closest_region]] <- c(region_vertex_dictionary[[closest_region]],i)
}
vertex_region_dictionary <- apply(distances,2,FUN = which.min)
causal_regions_1 <- c(1)
causal_regions_2 <- c(50)
shared_regions <- c(25,34)
causal_points <- 10
noise_points <- 10
### Start Timing
times <- 1:10
for(l in 1:10){
t1 <- Sys.time()
######################################################
###################### Compute EC #####################
######################################################
data <- matrix(NA,nrow=0,ncol = 1+curve_length*( dim(dir)[1]))
### Create the data ###
for (i in 1:nsim){
sphere1 = vcgSphere(subdivision = subdivision)
sphere2 = vcgSphere(subdivision = subdivision)
# Add noise to the sphere
sphere1$vb[1:3,] = sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
sphere2$vb[1:3,] = sphere2$vb[1:3,]  * rnorm(dim(sphere2$vb)[2], mean = 1, sd = 0.02)
# Elevate the causal regions - Needs to be changed
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 1.55 + rnorm(1, mean = 0, sd = 0.1)
}
for (j in 1:length(causal_regions_2)){
causal_dir2 = regions[causal_regions_2[j],]
closest_points_class2 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir2,ncol = 3), k = causal_points)
sphere2$vb[1:3,closest_points_class2] = sphere2$vb[1:3,closest_points_class2]  * 1.55 + rnorm(1, mean = 0, sd = 0.1)
}
# Elevate the shared regions - Needs to be changed
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere$vb[1:3,closest_points_shared]  * 0.55 + rnorm(1, mean = 0, sd = 0.1)
sphere1$vb[1:3,closest_points_shared] = shared_points
sphere2$vb[1:3,closest_points_shared] = shared_points
}
sphere_mesh1 = convert_off_file(sphere1)
sphere_mesh2 = convert_off_file(sphere2)
ec_curve_class1 <- matrix(NA,nrow = 1,ncol=0)
ec_curve_class2 <- matrix(NA,nrow = 1,ncol=0)
### compute EC curves for both classes of curves
for (j in 1:dim(dir)[1]){
vertex_function_class_1 <- sphere_mesh1$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
vertex_function_class_2 <- sphere_mesh2$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
curve1 <- compute_standardized_ec_curve(sphere_mesh1, vertex_function_class_1, curve_length-1, first_column_index = FALSE,ball_radius)
curve2 <- compute_standardized_ec_curve(sphere_mesh2, vertex_function_class_2, curve_length-1, first_column_index = FALSE,ball_radius)
# transform the ECT as desired
curve1 <- update_ec_curve(curve1, ec_type)
curve2 <- update_ec_curve(curve2, ec_type)
# omit the length data, for now
ec_curve_class1 <- c(ec_curve_class1,curve1[,2])
ec_curve_class2 <- c(ec_curve_class2,curve2[,2])
}
data <- rbind(data,c(1,ec_curve_class1))
data <- rbind(data,c(-1,ec_curve_class2))
}
######################################################
###################### Apply RATE / Reconstruct #####################
######################################################
### Run the model + select features with RATE
# how does bandwidth impact reconstruction?
rate_values_sim <- find_rate_variables_with_other_sampling_methods(data,radius = 0, bandwidth = 0.1,
weights = TRUE, type = 'ESS')[,2]
### Plot it back onto shape, and make rotating plot
sphere1 <- vcgSphere(subdivision = subdivision)
sphere1$vb[1:3,] <- sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
### Plot it back onto shape, and make rotating plot
sphere2 <- vcgSphere(subdivision = subdivision)
sphere2$vb[1:3,] <- sphere2$vb[1:3,]  * rnorm(dim(sphere2$vb)[2], mean = 1, sd = 0.02)
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 1.55
}
for (j in 1:length(causal_regions_2)){
causal_dir2 = regions[causal_regions_2[j],]
closest_points_class2 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir2,ncol = 3), k = causal_points)
sphere2$vb[1:3,closest_points_class2] = sphere2$vb[1:3,closest_points_class2]  * 1.55
}
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere1$vb[1:3,closest_points_shared]  * 0.55
sphere1$vb[1:3,closest_points_shared] = shared_points
shared_points = sphere2$vb[1:3,closest_points_shared]  * 0.55
sphere2$vb[1:3,closest_points_shared] = shared_points
}
complex1<- convert_off_file(sphere1)
complex2 <- convert_off_file(sphere2)
# reconstruct birth times of vertices
vert_matrix1 <- reconstruct_vertices_on_shape(dir, complex1, rate_values_sim, curve_length, cuts = 300,
directions_per_cone, ball_radius, TRUE)
vert_matrix2 <- reconstruct_vertices_on_shape(dir, complex2, rate_values_sim, curve_length, cuts = 300,
directions_per_cone, ball_radius, TRUE)
t2 <- Sys.time()
simulation.time <- as.numeric(t2 - t1, units = "secs")
times[l] <- simulation.time
}
ec_type <- 'ECT'
for(l in 1:10){
t1 <- Sys.time()
######################################################
###################### Compute EC #####################
######################################################
data <- matrix(NA,nrow=0,ncol = 1+curve_length*( dim(dir)[1]))
### Create the data ###
for (i in 1:nsim){
sphere1 = vcgSphere(subdivision = subdivision)
sphere2 = vcgSphere(subdivision = subdivision)
# Add noise to the sphere
sphere1$vb[1:3,] = sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
sphere2$vb[1:3,] = sphere2$vb[1:3,]  * rnorm(dim(sphere2$vb)[2], mean = 1, sd = 0.02)
# Elevate the causal regions - Needs to be changed
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 1.55 + rnorm(1, mean = 0, sd = 0.1)
}
for (j in 1:length(causal_regions_2)){
causal_dir2 = regions[causal_regions_2[j],]
closest_points_class2 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir2,ncol = 3), k = causal_points)
sphere2$vb[1:3,closest_points_class2] = sphere2$vb[1:3,closest_points_class2]  * 1.55 + rnorm(1, mean = 0, sd = 0.1)
}
# Elevate the shared regions - Needs to be changed
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere$vb[1:3,closest_points_shared]  * 0.55 + rnorm(1, mean = 0, sd = 0.1)
sphere1$vb[1:3,closest_points_shared] = shared_points
sphere2$vb[1:3,closest_points_shared] = shared_points
}
sphere_mesh1 = convert_off_file(sphere1)
sphere_mesh2 = convert_off_file(sphere2)
ec_curve_class1 <- matrix(NA,nrow = 1,ncol=0)
ec_curve_class2 <- matrix(NA,nrow = 1,ncol=0)
### compute EC curves for both classes of curves
for (j in 1:dim(dir)[1]){
vertex_function_class_1 <- sphere_mesh1$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
vertex_function_class_2 <- sphere_mesh2$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])
curve1 <- compute_standardized_ec_curve(sphere_mesh1, vertex_function_class_1, curve_length-1, first_column_index = FALSE,ball_radius)
curve2 <- compute_standardized_ec_curve(sphere_mesh2, vertex_function_class_2, curve_length-1, first_column_index = FALSE,ball_radius)
# transform the ECT as desired
curve1 <- update_ec_curve(curve1, ec_type)
curve2 <- update_ec_curve(curve2, ec_type)
# omit the length data, for now
ec_curve_class1 <- c(ec_curve_class1,curve1[,2])
ec_curve_class2 <- c(ec_curve_class2,curve2[,2])
}
data <- rbind(data,c(1,ec_curve_class1))
data <- rbind(data,c(-1,ec_curve_class2))
}
######################################################
###################### Apply RATE / Reconstruct #####################
######################################################
### Run the model + select features with RATE
# how does bandwidth impact reconstruction?
rate_values_sim <- find_rate_variables_with_other_sampling_methods(data,radius = 0, bandwidth = 0.1,
weights = TRUE, type = 'ESS')[,2]
### Plot it back onto shape, and make rotating plot
sphere1 <- vcgSphere(subdivision = subdivision)
sphere1$vb[1:3,] <- sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)
### Plot it back onto shape, and make rotating plot
sphere2 <- vcgSphere(subdivision = subdivision)
sphere2$vb[1:3,] <- sphere2$vb[1:3,]  * rnorm(dim(sphere2$vb)[2], mean = 1, sd = 0.02)
for (j in 1:length(causal_regions_1)){
causal_dir1 = regions[causal_regions_1[j],]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)
sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 1.55
}
for (j in 1:length(causal_regions_2)){
causal_dir2 = regions[causal_regions_2[j],]
closest_points_class2 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir2,ncol = 3), k = causal_points)
sphere2$vb[1:3,closest_points_class2] = sphere2$vb[1:3,closest_points_class2]  * 1.55
}
for (k in 1:length(shared_regions)){
shared_dir = regions[shared_regions[k],]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)
shared_points = sphere1$vb[1:3,closest_points_shared]  * 0.55
sphere1$vb[1:3,closest_points_shared] = shared_points
shared_points = sphere2$vb[1:3,closest_points_shared]  * 0.55
sphere2$vb[1:3,closest_points_shared] = shared_points
}
complex1<- convert_off_file(sphere1)
complex2 <- convert_off_file(sphere2)
# reconstruct birth times of vertices
vert_matrix1 <- reconstruct_vertices_on_shape(dir, complex1, rate_values_sim, curve_length, cuts = 300,
directions_per_cone, ball_radius, TRUE)
vert_matrix2 <- reconstruct_vertices_on_shape(dir, complex2, rate_values_sim, curve_length, cuts = 300,
directions_per_cone, ball_radius, TRUE)
t2 <- Sys.time()
simulation.time <- as.numeric(t2 - t1, units = "secs")
times[l] <- simulation.time
}
avg_time
avg_time <- mean(times)
avg_time
#fileConn<-file("~/data/SINATRA/timingresults.txt")
fileConn<-file("~/Desktop/timingresults.txt")
print(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
shapes_per_class, num_cones, directions_per_cone,
ec_curve_length, avg_time), fileConn)
print(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
nsim, num_cones, directions_per_cone,
ec_curve_length, avg_time), fileConn)
print(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
nsim, num_cones, directions_per_cone,
curve_length, avg_time), fileConn)
close(fileConn)
fileConn<-file("~/Desktop/timing.txt")
print(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
nsim, num_cones, directions_per_cone,
curve_length, avg_time), fileConn)
close(fileConn)
fileConn<-file("~/Desktop/timing.txt")
write(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
nsim, num_cones, directions_per_cone,
curve_length, avg_time), fileConn)
close(fileConn)
#file <- "~/data/SINATRA/timingresults.txt"
file <- "~/Desktop/timingresults.txt"
cat(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
nsim, num_cones, directions_per_cone,
curve_length, avg_time), file)
cat(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
nsim, num_cones, directions_per_cone,
curve_length, avg_time), file, append=TRUE)
cat(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
nsim, num_cones, directions_per_cone,
curve_length, avg_time), file, append=TRUE, sep = "\n")
#fileConn<-file("~/data/SINATRA/timingresults.txt")
fileConn<-file("~/Desktop/timingresults.txt")
write(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
nsim, num_cones, directions_per_cone,
curve_length, avg_time), fileConn, append = TRUE)
#fileConn<-file("~/data/SINATRA/timingresults.txt")
fileConn<-file("~/Desktop/timingresults.txt")
write(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
nsim, num_cones, directions_per_cone,
curve_length, avg_time), fileConn, append = TRUE)
close(fileConn)
#fileConn<-file("~/data/SINATRA/timingresults.txt")
fileConn<-file("~/Desktop/timing.txt")
write(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
nsim, num_cones, directions_per_cone,
curve_length, avg_time), fileConn, append = TRUE)
close(fileConn)
#fileConn<-file("~/data/SINATRA/timingresults.txt")
fileConn<-file("~/Desktop/timing.txt")
write(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
nsim, num_cones, directions_per_cone,
curve_length, avg_time), fileConn, append = TRUE)
close(fileConn)
#fileConn<-file("~/data/SINATRA/timingresults.txt")
fileConn<-file("~/Desktop/timing.txt")
write(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
nsim, num_cones, directions_per_cone,
curve_length, 10), fileConn, append = TRUE)
close(fileConn)
#file <-"~/data/SINATRA/timingresults.txt"
file <- "~/Desktop/timing.txt"
cat(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
nsim, num_cones, directions_per_cone,
curve_length, 10), file , append = TRUE)
#file <-"~/data/SINATRA/timingresults.txt"
file <- "~/Desktop/timing.txt"
cat(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
nsim, num_cones, directions_per_cone,
curve_length, 10), file = file, append = TRUE, sep = "\n")
cat(sprintf("shapes: %d , num_cones: %d , dirpercone: %d , ec_curve: %d , time: %f ",
nsim, num_cones, directions_per_cone,
curve_length, 10), file = file, append = TRUE, sep = "\n")
setwd("~/projects/Research/SINATRA")
RcppArmadillo.package.skeleton(name = "sinatra")
install.packages("RcppArmadillo")
RcppArmadillo.package.skeleton(name = "sinatra")
library(RcppArmadillo)
RcppArmadillo.package.skeleton(name = "sinatra")
RcppArmadillo.package.skeleton(name = "SINATRA")
RcppArmadillo.package.skeleton(name = "Sinatra_test_package")
setwd("~/projects/Research/SINATRA/Sinatra_test_package/src")
