directions <- generate_equidistributed_cones(num_cones,cap_radius,directions_per_cone)
data <- generate_data_sphere_simulation_baseline(nsim = nsim,dir = directions, curve_length = curve_length,noise_points = shared_points,
causal_points = causal_points, ball_radius = ball_radius, subdivision = subdivision,
cusps = cusps, causal_regions_1 = causal_regions_1, causal_regions_2 = causal_regions_2,
shared_regions = shared_regions, ec_type = ec_type)
directions <- directions
ec_curve_data <- data$data
}
else{
print(mode)
directions <- generate_equidistributed_cones(num_cones,cap_radius,directions_per_cone)
data <- create_data_normal_fixed(num_sim = nsim, dir = directions, curve_length = curve_length,shared_points = shared_points,
causal_points = causal_points,grid_size = grid_size,eta = eta,ball_radius = ball_radius,
ec_type = ec_type)
directions <- directions
ec_curve_data <- data$data
}
num_cones <- dim(directions)[1]/directions_per_cone
print("getting rate values")
if (mode == 'sphere_baseline'){
rate_values = abs(find_elastic_variables(ec_curve_data,weights = TRUE))
rate_values[,1] = rep((1:(dim(rate_values)[1]/3)),each = 3)
library(dplyr)
df = as.data.table(rate_values)
new_df = aggregate(df[,2],list(df$V1),max)
rate_values = new_df$V2
}
else{
rate_values = abs(find_elastic_variables(ec_curve_data,weights = TRUE))[,2]
#rate_values <- find_rate_variables_with_other_sampling_methods(ec_curve_data, bandwidth = 0.01, type = 'ESS')[,2]
}
#Indices for Two Classes
index1 = seq(1,nsim,2)
complex_points1 = data$complex_points[index1]
index2 = seq(2,nsim,2)
complex_points2 = data$complex_points[index2]
#Compute ROC using training data
if (type == 'vertex'){
if (two_curves == TRUE){
roc_curve1 =  compute_roc_curve_vertex(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, directions = directions, class = 1,truncated = truncated,
ball_radius = ball_radius, radius = radius, mode = mode,subdivision = subdivision)
roc_curve1 = cbind(roc_curve1, rep(1,dim(roc_curve1)[1]))
roc_curve1 = cbind(roc_curve1,(1:dim(roc_curve1)[1]))
roc_curve2 =  compute_roc_curve_vertex(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, directions = directions,class = 2,truncated = truncated,
ball_radius = ball_radius, radius = radius, mode = mode, subdivision = subdivision)
roc_curve2 = cbind(roc_curve2, rep(2,dim(roc_curve2)[1]))
roc_curve2 = cbind(roc_curve2,(1:dim(roc_curve2)[1]))
roc_curve = rbind(roc_curve1,roc_curve2)
}
else{
roc_curve = compute_roc_curve_vertex(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, directions = directions,  class = 0, truncated = truncated,
ball = ball, ball_radius = ball_radius, radius = radius, mode = mode, subdivision = subdivision)
roc_curve = cbind(roc_curve,(1:dim(roc_curve)[1]))
}
return(roc_curve)
}
if (type == 'feature'){
roc_curve = compute_roc_curve_features(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, class = 0, truncated = truncated,
ball = ball,ball_radius = ball_radius,
dir = directions, min_points = min_points,mode = mode, subdivision = subdivision)
roc_curve = cbind(roc_curve,(1:dim(roc_curve)[1]))
return(roc_curve)
}
if (type == 'cone'){
print('cone')
roc_curve = compute_roc_curve_cones(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, class = 0, truncated = truncated,
ball = ball, ball_radius = ball_radius,
dir = directions,  min_points = min_points, radius = radius,mode = mode, subdivision = subdivision)
roc_curve = cbind(roc_curve,(1:dim(roc_curve)[1]))
return(roc_curve)
}
if (type == 'cusp'){
print('cusp')
roc_curve = compute_roc_curve_modified_vertex(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, class = 0, truncated = truncated,
ball = ball, ball_radius = ball_radius,
dir = directions, radius = radius,mode = mode, subdivision = subdivision)
roc_curve = cbind(roc_curve,(1:dim(roc_curve)[1]))
return(roc_curve)
}
}
#### ROC TEST ####
g = generate_averaged_ROC_with_coned_directions(runs = 5, nsim = 50, curve_length = 30, grid_size = 25, distance_to_causal_point = 0.1,
causal_points = causal_points,shared_points = shared_points, num_cones = 30, eta = 0.1,
truncated = 200, two_curves = TRUE, ball = TRUE, ball_radius = 1.5, type = 'vertex',
min_points = 3, directions_per_cone = 5, cap_radius = 0.15, radius = 1,ec_type = 'ECT',
mode = 'sphere',num_cusps = cusps,
subdivision = 3,num_causal_region = num_causal_region, num_shared_region = num_shared_region)
#### ROC TEST ####
g = generate_averaged_ROC_with_coned_directions(runs = 5, nsim = 25, curve_length = 30, grid_size = 25, distance_to_causal_point = 0.1,
causal_points = causal_points,shared_points = shared_points, num_cones = 20, eta = 0.1,
truncated = 200, two_curves = TRUE, ball = TRUE, ball_radius = 1.5, type = 'vertex',
min_points = 3, directions_per_cone = 5, cap_radius = 0.15, radius = 1,ec_type = 'ECT',
mode = 'sphere',num_cusps = cusps,
subdivision = 3,num_causal_region = num_causal_region, num_shared_region = num_shared_region)
roc_curve_frame = data.frame(g)
library(ggplot2)
ggplot(roc_curve_frame, aes(x = X1,y = X2,group = X3)) + geom_line(alpha = 0.8, size = 2,aes(color = factor(X3) )) +
geom_abline(slope = 1,intercept = 0) +
scale_x_continuous(name='False Positive Rate',limits=c(0,1)) +
scale_y_continuous(name='True Positive Rate', limits=c(0,1)) +
labs(color='Class') +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"),
plot.title = element_text(size=10)) + ggtitle(label = "ROC Curve for 30 Cones, 2 Causal Region, 1 Shared Region")
generate_ROC_with_coned_directions <- function(nsim = 10, curve_length = 25, grid_size = 25, distance_to_causal_point = 0.1,
causal_points = 10,shared_points = 3, num_cones = 5, eta = 0.1, num_cusps = 10,
truncated = 300, two_curves = TRUE, ball = TRUE, ball_radius = 2.5, type = 'vertex',
min_points = 3,directions_per_cone = 4, cap_radius = 0.15, radius = 0,ec_type = 'ECT',
mode = 'sphere',
subdivision = 3,num_causal_region = 5, num_shared_region = 5){
print("generating directions")
print("generating data")
# generate data
if (mode == 'sphere'){
#cusps = 2*num_causal_region + num_shared_region + 1
cusps = num_cusps
causal_dirs = generate_equidistributed_points(cusps,cusps)
causal_regions_1 = sample(1:cusps,num_causal_region)
causal_regions_2 = sample((1:cusps)[-causal_regions_1],num_causal_region)
shared_regions = sample((1:cusps)[-c(causal_regions_1,causal_regions_2)],num_shared_region)
directions <- generate_equidistributed_cones(num_cones,cap_radius,directions_per_cone)
data <- generate_data_sphere_simulation(nsim = nsim,dir = directions, curve_length = curve_length,noise_points = shared_points,
causal_points = causal_points, ball_radius = ball_radius, subdivision = subdivision,
cusps = cusps, causal_regions_1 = causal_regions_1, causal_regions_2 = causal_regions_2,
shared_regions = shared_regions, ec_type = ec_type)
directions <- directions
ec_curve_data <- data$data
}
else if (mode == 'gaussian_grid'){
print(mode)
directions <- generate_equidistributed_cones(num_cones,cap_radius,directions_per_cone)
data <- generate_data_gaussian_field(nsim = nsim, dir = directions, curve_length = curve_length,shared_points = shared_points,
causal_points = causal_points,grid_size = grid_size,ball_radius = ball_radius,
ec_type = ec_type)
directions <- directions
ec_curve_data <- data$data
}
else if (mode == 'sphere_baseline'){
print(mode)
cusps = num_cusps
causal_dirs = generate_equidistributed_points(cusps,cusps)
causal_regions_1 = sample(1:cusps,num_causal_region)
causal_regions_2 = sample((1:cusps)[-causal_regions_1],num_causal_region)
shared_regions = sample((1:cusps)[-c(causal_regions_1,causal_regions_2)],num_shared_region)
directions <- generate_equidistributed_cones(num_cones,cap_radius,directions_per_cone)
data <- generate_data_sphere_simulation_baseline(nsim = nsim,dir = directions, curve_length = curve_length,noise_points = shared_points,
causal_points = causal_points, ball_radius = ball_radius, subdivision = subdivision,
cusps = cusps, causal_regions_1 = causal_regions_1, causal_regions_2 = causal_regions_2,
shared_regions = shared_regions, ec_type = ec_type)
directions <- directions
ec_curve_data <- data$data
}
else{
print(mode)
directions <- generate_equidistributed_cones(num_cones,cap_radius,directions_per_cone)
data <- create_data_normal_fixed(num_sim = nsim, dir = directions, curve_length = curve_length,shared_points = shared_points,
causal_points = causal_points,grid_size = grid_size,eta = eta,ball_radius = ball_radius,
ec_type = ec_type)
directions <- directions
ec_curve_data <- data$data
}
num_cones <- dim(directions)[1]/directions_per_cone
print("getting rate values")
if (mode == 'sphere_baseline'){
rate_values = abs(find_elastic_variables(ec_curve_data,weights = TRUE))
rate_values[,1] = rep((1:(dim(rate_values)[1]/3)),each = 3)
library(dplyr)
df = as.data.table(rate_values)
new_df = aggregate(df[,2],list(df$V1),max)
rate_values = new_df$V2
}
else{
print('Running RATE')
rate_values = abs(find_elastic_variables(ec_curve_data,weights = TRUE))[,2]
#rate_values <- find_rate_variables_with_other_sampling_methods(ec_curve_data, bandwidth = 0.01, type = 'ESS')[,2]
}
#Indices for Two Classes
index1 = seq(1,nsim,2)
complex_points1 = data$complex_points[index1]
index2 = seq(2,nsim,2)
complex_points2 = data$complex_points[index2]
#Compute ROC using training data
if (type == 'vertex'){
if (two_curves == TRUE){
roc_curve1 =  compute_roc_curve_vertex(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, directions = directions, class = 1,truncated = truncated,
ball_radius = ball_radius, radius = radius, mode = mode,subdivision = subdivision)
roc_curve1 = cbind(roc_curve1, rep(1,dim(roc_curve1)[1]))
roc_curve1 = cbind(roc_curve1,(1:dim(roc_curve1)[1]))
roc_curve2 =  compute_roc_curve_vertex(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, directions = directions,class = 2,truncated = truncated,
ball_radius = ball_radius, radius = radius, mode = mode, subdivision = subdivision)
roc_curve2 = cbind(roc_curve2, rep(2,dim(roc_curve2)[1]))
roc_curve2 = cbind(roc_curve2,(1:dim(roc_curve2)[1]))
roc_curve = rbind(roc_curve1,roc_curve2)
}
else{
roc_curve = compute_roc_curve_vertex(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, directions = directions,  class = 0, truncated = truncated,
ball = ball, ball_radius = ball_radius, radius = radius, mode = mode, subdivision = subdivision)
roc_curve = cbind(roc_curve,(1:dim(roc_curve)[1]))
}
return(roc_curve)
}
if (type == 'feature'){
roc_curve = compute_roc_curve_features(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, class = 0, truncated = truncated,
ball = ball,ball_radius = ball_radius,
dir = directions, min_points = min_points,mode = mode, subdivision = subdivision)
roc_curve = cbind(roc_curve,(1:dim(roc_curve)[1]))
return(roc_curve)
}
if (type == 'cone'){
print('cone')
roc_curve = compute_roc_curve_cones(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, class = 0, truncated = truncated,
ball = ball, ball_radius = ball_radius,
dir = directions,  min_points = min_points, radius = radius,mode = mode, subdivision = subdivision)
roc_curve = cbind(roc_curve,(1:dim(roc_curve)[1]))
return(roc_curve)
}
if (type == 'cusp'){
print('cusp')
roc_curve = compute_roc_curve_modified_vertex(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, class = 0, truncated = truncated,
ball = ball, ball_radius = ball_radius,
dir = directions, radius = radius,mode = mode, subdivision = subdivision)
roc_curve = cbind(roc_curve,(1:dim(roc_curve)[1]))
return(roc_curve)
}
}
#### ROC TEST ####
g = generate_averaged_ROC_with_coned_directions(runs = 5, nsim = 25, curve_length = 30, grid_size = 25, distance_to_causal_point = 0.1,
causal_points = causal_points,shared_points = shared_points, num_cones = 20, eta = 0.1,
truncated = 200, two_curves = TRUE, ball = TRUE, ball_radius = 1.5, type = 'vertex',
min_points = 3, directions_per_cone = 5, cap_radius = 0.15, radius = 1,ec_type = 'ECT',
mode = 'sphere',num_cusps = cusps,
subdivision = 3,num_causal_region = num_causal_region, num_shared_region = num_shared_region)
library(devtools)
setwd('~/Documents/SINATRA/sinatra/')
generate_ROC_with_coned_directions_dummy <- function(nsim = 10, curve_length = 25, grid_size = 25, distance_to_causal_point = 0.1,
causal_points = 10,shared_points = 3, num_cones = 5, eta = 0.1, num_cusps = 10,
truncated = 300, two_curves = TRUE, ball = TRUE, ball_radius = 2.5, type = 'vertex',
min_points = 3,directions_per_cone = 4, cap_radius = 0.15, radius = 0,ec_type = 'ECT',
mode = 'sphere',
subdivision = 3,num_causal_region = 5, num_shared_region = 5){
print("generating directions")
print("generating data")
# generate data
if (mode == 'sphere'){
#cusps = 2*num_causal_region + num_shared_region + 1
cusps = num_cusps
causal_dirs = generate_equidistributed_points(cusps,cusps)
causal_regions_1 = sample(1:cusps,num_causal_region)
causal_regions_2 = sample((1:cusps)[-causal_regions_1],num_causal_region)
shared_regions = sample((1:cusps)[-c(causal_regions_1,causal_regions_2)],num_shared_region)
directions <- generate_equidistributed_cones(num_cones,cap_radius,directions_per_cone)
data <- generate_data_sphere_simulation(nsim = nsim,dir = directions, curve_length = curve_length,noise_points = shared_points,
causal_points = causal_points, ball_radius = ball_radius, subdivision = subdivision,
cusps = cusps, causal_regions_1 = causal_regions_1, causal_regions_2 = causal_regions_2,
shared_regions = shared_regions, ec_type = ec_type)
directions <- directions
ec_curve_data <- data$data
}
else if (mode == 'gaussian_grid'){
print(mode)
directions <- generate_equidistributed_cones(num_cones,cap_radius,directions_per_cone)
data <- generate_data_gaussian_field(nsim = nsim, dir = directions, curve_length = curve_length,shared_points = shared_points,
causal_points = causal_points,grid_size = grid_size,ball_radius = ball_radius,
ec_type = ec_type)
directions <- directions
ec_curve_data <- data$data
}
else if (mode == 'sphere_baseline'){
print(mode)
cusps = num_cusps
causal_dirs = generate_equidistributed_points(cusps,cusps)
causal_regions_1 = sample(1:cusps,num_causal_region)
causal_regions_2 = sample((1:cusps)[-causal_regions_1],num_causal_region)
shared_regions = sample((1:cusps)[-c(causal_regions_1,causal_regions_2)],num_shared_region)
directions <- generate_equidistributed_cones(num_cones,cap_radius,directions_per_cone)
data <- generate_data_sphere_simulation_baseline(nsim = nsim,dir = directions, curve_length = curve_length,noise_points = shared_points,
causal_points = causal_points, ball_radius = ball_radius, subdivision = subdivision,
cusps = cusps, causal_regions_1 = causal_regions_1, causal_regions_2 = causal_regions_2,
shared_regions = shared_regions, ec_type = ec_type)
directions <- directions
ec_curve_data <- data$data
}
else{
print(mode)
directions <- generate_equidistributed_cones(num_cones,cap_radius,directions_per_cone)
data <- create_data_normal_fixed(num_sim = nsim, dir = directions, curve_length = curve_length,shared_points = shared_points,
causal_points = causal_points,grid_size = grid_size,eta = eta,ball_radius = ball_radius,
ec_type = ec_type)
directions <- directions
ec_curve_data <- data$data
}
num_cones <- dim(directions)[1]/directions_per_cone
print("getting rate values")
if (mode == 'sphere_baseline'){
rate_values = abs(find_elastic_variables(ec_curve_data,weights = TRUE))
rate_values[,1] = rep((1:(dim(rate_values)[1]/3)),each = 3)
library(dplyr)
df = as.data.table(rate_values)
new_df = aggregate(df[,2],list(df$V1),max)
rate_values = new_df$V2
}
else{
print('Running RATE')
rate_values = abs(find_elastic_variables(ec_curve_data,weights = TRUE))[,2]
#rate_values <- find_rate_variables_with_other_sampling_methods(ec_curve_data, bandwidth = 0.01, type = 'ESS')[,2]
}
#Indices for Two Classes
index1 = seq(1,nsim,2)
complex_points1 = data$complex_points[index1]
index2 = seq(2,nsim,2)
complex_points2 = data$complex_points[index2]
#Compute ROC using training data
if (type == 'vertex'){
if (two_curves == TRUE){
roc_curve1 =  compute_roc_curve_vertex(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, directions = directions, class = 1,truncated = truncated,
ball_radius = ball_radius, radius = radius, mode = mode,subdivision = subdivision)
roc_curve1 = cbind(roc_curve1, rep(1,dim(roc_curve1)[1]))
roc_curve1 = cbind(roc_curve1,(1:dim(roc_curve1)[1]))
roc_curve2 =  compute_roc_curve_vertex(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, directions = directions,class = 2,truncated = truncated,
ball_radius = ball_radius, radius = radius, mode = mode, subdivision = subdivision)
roc_curve2 = cbind(roc_curve2, rep(2,dim(roc_curve2)[1]))
roc_curve2 = cbind(roc_curve2,(1:dim(roc_curve2)[1]))
roc_curve = rbind(roc_curve1,roc_curve2)
}
else{
roc_curve = compute_roc_curve_vertex(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, directions = directions,  class = 0, truncated = truncated,
ball = ball, ball_radius = ball_radius, radius = radius, mode = mode, subdivision = subdivision)
roc_curve = cbind(roc_curve,(1:dim(roc_curve)[1]))
}
return(roc_curve)
}
if (type == 'feature'){
roc_curve = compute_roc_curve_features(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, class = 0, truncated = truncated,
ball = ball,ball_radius = ball_radius,
dir = directions, min_points = min_points,mode = mode, subdivision = subdivision)
roc_curve = cbind(roc_curve,(1:dim(roc_curve)[1]))
return(roc_curve)
}
if (type == 'cone'){
print('cone')
roc_curve = compute_roc_curve_cones(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, class = 0, truncated = truncated,
ball = ball, ball_radius = ball_radius,
dir = directions,  min_points = min_points, radius = radius,mode = mode, subdivision = subdivision)
roc_curve = cbind(roc_curve,(1:dim(roc_curve)[1]))
return(roc_curve)
}
if (type == 'cusp'){
print('cusp')
roc_curve = compute_roc_curve_modified_vertex(data = data, class_1_causal_points = data$causal_points1, class_2_causal_points = data$causal_points2,
curve_length = curve_length, distance_to_causal_point = distance_to_causal_point, rate_values = rate_values, grid_size = grid_size,
eta = eta, directions_per_cone = directions_per_cone, class = 0, truncated = truncated,
ball = ball, ball_radius = ball_radius,
dir = directions, radius = radius,mode = mode, subdivision = subdivision)
roc_curve = cbind(roc_curve,(1:dim(roc_curve)[1]))
return(roc_curve)
}
}
#### ROC TEST ####
g = generate_averaged_ROC_with_coned_directions_dummy(runs = 5, nsim = 25, curve_length = 30, grid_size = 25, distance_to_causal_point = 0.1,
causal_points = causal_points,shared_points = shared_points, num_cones = 20, eta = 0.1,
truncated = 200, two_curves = TRUE, ball = TRUE, ball_radius = 1.5, type = 'vertex',
min_points = 3, directions_per_cone = 5, cap_radius = 0.15, radius = 1,ec_type = 'ECT',
mode = 'sphere',num_cusps = cusps,
subdivision = 3,num_causal_region = num_causal_region, num_shared_region = num_shared_region)
#' 'cusp' (finding causal cusps for spheres).
#' @param min_points (int) : Used when type = 'feature'. The mininum number of causal vertices for a sub-level set to be associated with to be considered a causal 'feature'.
#' @param directions_per_cone (int): The number of directions we want generated within each cone.
#' @param cap_radius (float): The radius of the cones we generate (determines the size of each cone).
#' @param radius (int) : The number of sub-level sets "before" and "after" the selected sub-level sets we want to include (during reconstruction).
#' @param mode (string) : The data generation scheme. We currently support 'sphere', 'gaussian_grid", or rbf interpolations (default).
#' @param subdivision (int) : The fineness of the sphere meshes (if mode == 'sphere'). We currently use subdivision = 3.
#' @param num_causal_region (int) : The number of causal cusps (for when mode == 'sphere').
#' @param num_shared_region (int) : The number of shared cusps (for when mode == 'sphere').
#' @param ec_type (string) : The type of EC we are computing. We currently support ECT, DECT and SECT.
generate_averaged_ROC_with_coned_directions_dummy  <- function(runs = 5, nsim = 50, curve_length = 10, grid_size = 25, distance_to_causal_point = 0.1, causal_points = 10,
shared_points = 3, num_cones = 5, eta = 0.1, truncated = FALSE, two_curves = FALSE,
ball_radius = 2, ball = TRUE, type = 'vertex',min_points = 2,directions_per_cone = 5, cap_radius = 0.15,
radius = 0, mode = 'sphere', num_cusps = 10,
subdivision = 3, num_causal_region = 5, num_shared_region = 5,
ec_type = 'ECT'){
if (type == 'vertex'){
roc_curves = list()
roc_curves2 = list()
roc_curves3 = list()
i = 1
while (i<runs+1){
roc_curve = try(generate_ROC_with_coned_directions_dummy(nsim = nsim, curve_length = curve_length, grid_size = grid_size, distance_to_causal_point = distance_to_causal_point,
causal_points = causal_points,shared_points = shared_points,num_cones = num_cones,
eta = eta,truncated = truncated, two_curves = two_curves, num_cusps = num_cusps,
ball = ball, ball_radius = ball_radius,type = type, min_points = min_points,num_causal_region = num_causal_region,
num_shared_region = num_shared_region,cap_radius = cap_radius,radius = radius,
directions_per_cone = directions_per_cone, mode = mode,ec_type = ec_type))
if (inherits(roc_curve,'try-error')){
next
}
else{
roc_curves[[i]] = roc_curve
if (two_curves == TRUE){
roc_curves2[[i]] = as.matrix(roc_curve[which(roc_curve[,3]==1),])[,1:2]
roc_curves3[[i]] = as.matrix(roc_curve[which(roc_curve[,3]==2),])[,1:2]
}
else{
roc_curves2[[i]] = as.matrix(roc_curve[which(roc_curve[,3]==0),])[,1:2]
}
i = i+1
}
}
total_roc = matrix(0, nrow = dim(roc_curves[[1]]), ncol = dim(roc_curves[[1]])[2])
for (j in 1:runs){
total_roc = total_roc + roc_curves[[j]]
}
total_roc = total_roc/runs
return(total_roc)
}
if (type == 'feature' | type == 'cone' | type == 'cusp'){
roc_curves = list()
i = 1
while (i<runs+1){
roc_curve = try(generate_ROC_with_coned_directions(nsim = nsim, curve_length = curve_length, grid_size = grid_size, distance_to_causal_point = distance_to_causal_point,
causal_points = causal_points,shared_points = shared_points,num_cones = num_cones,
eta = eta,truncated = truncated, two_curves = two_curves,num_cusps = num_cusps,
ball = ball, ball_radius = ball_radius,type = type, min_points = min_points,num_causal_region = num_causal_region,
num_shared_region = num_shared_region,cap_radius = cap_radius,radius = radius,
directions_per_cone = directions_per_cone, mode = mode,ec_type = ec_type))
if (inherits(roc_curve,'try-error')){
next
}
else{
roc_curves[[i]] = roc_curve
}
i = i+1
}
total_roc = matrix(0, nrow = dim(roc_curves[[1]]), ncol = dim(roc_curves[[1]])[2])
for (j in 1:runs){
total_roc = total_roc + roc_curves[[j]]
}
total_roc = total_roc/runs
return(total_roc)
}
}
#### ROC TEST ####
g = generate_averaged_ROC_with_coned_directions_dummy(runs = 5, nsim = 25, curve_length = 30, grid_size = 25, distance_to_causal_point = 0.1,
causal_points = causal_points,shared_points = shared_points, num_cones = 20, eta = 0.1,
truncated = 200, two_curves = TRUE, ball = TRUE, ball_radius = 1.5, type = 'vertex',
min_points = 3, directions_per_cone = 5, cap_radius = 0.15, radius = 1,ec_type = 'ECT',
mode = 'sphere',num_cusps = cusps,
subdivision = 3,num_causal_region = num_causal_region, num_shared_region = num_shared_region)
library(glmnet)
#### ROC TEST ####
g = generate_averaged_ROC_with_coned_directions_dummy(runs = 5, nsim = 25, curve_length = 30, grid_size = 25, distance_to_causal_point = 0.1,
causal_points = causal_points,shared_points = shared_points, num_cones = 20, eta = 0.1,
truncated = 200, two_curves = TRUE, ball = TRUE, ball_radius = 1.5, type = 'vertex',
min_points = 3, directions_per_cone = 5, cap_radius = 0.15, radius = 1,ec_type = 'ECT',
mode = 'sphere',num_cusps = cusps,
subdivision = 3,num_causal_region = num_causal_region, num_shared_region = num_shared_region)
roc_curve_frame = data.frame(g)
library(ggplot2)
ggplot(roc_curve_frame, aes(x = X1,y = X2,group = X3)) + geom_line(alpha = 0.8, size = 2,aes(color = factor(X3) )) +
geom_abline(slope = 1,intercept = 0) +
scale_x_continuous(name='False Positive Rate',limits=c(0,1)) +
scale_y_continuous(name='True Positive Rate', limits=c(0,1)) +
labs(color='Class') +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"),
plot.title = element_text(size=10)) + ggtitle(label = "ROC Curve for 30 Cones, 2 Causal Region, 1 Shared Region")
ggplot(roc_curve_frame, aes(x = X1,y = X2,group = X3)) + geom_line(alpha = 0.8, size = 2,aes(color = factor(X3) )) +
geom_abline(slope = 1,intercept = 0) +
scale_x_continuous(name='False Positive Rate',limits=c(0,1)) +
scale_y_continuous(name='True Positive Rate', limits=c(0,1)) +
labs(color='Class') +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"),
plot.title = element_text(size=10)) + ggtitle(label = "ROC Curve for 20 Cones, 2 Causal Region, 1 Shared Region")
library(devtools)
setwd('~/Documents/SINATRA/sinatra/')
build()
install(.)
install('.')
