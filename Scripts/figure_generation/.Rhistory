shared_dir = regions[shared_regions[k], ]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,
]), query = matrix(shared_dir, ncol = 3), k = noise_points)
total_shared_points = c(total_shared_points, closest_points_shared)
}
data <- matrix(NA, nrow = 0, ncol = (1+length(sphere$vb)))
for (i in 1:nsim) {
sphere1 = vcgSphere(subdivision = subdivision)
sphere2 = vcgSphere(subdivision = subdivision)
sphere1$vb[1:3, ] = sphere1$vb[1:3, ] * rnorm(dim(sphere1$vb)[2],
mean = 1, sd = 0.035)
sphere2$vb[1:3, ] = sphere2$vb[1:3, ] * rnorm(dim(sphere2$vb)[2],
mean = 1, sd = 0.035)
for (j in 1:length(causal_regions_1)) {
causal_dir1 = regions[causal_regions_1[j], ]
closest_points_class1 = knnx.index(data = t(sphere$vb[-4,
]), query = matrix(causal_dir1, ncol = 3), k = causal_points)
sphere1$vb[1:3, closest_points_class1] = sphere1$vb[1:3,
closest_points_class1] * 0.55 + rnorm(1, mean = 0,
sd = 0.1)
}
for (j in 1:length(causal_regions_2)) {
causal_dir2 = regions[causal_regions_2[j], ]
closest_points_class2 = knnx.index(data = t(sphere$vb[-4,
]), query = matrix(causal_dir2, ncol = 3), k = causal_points)
sphere2$vb[1:3, closest_points_class2] = sphere2$vb[1:3,
closest_points_class2] * 0.55 + rnorm(1, mean = 0,
sd = 0.1)
}
for (k in 1:length(shared_regions)) {
shared_dir = regions[shared_regions[k], ]
closest_points_shared = knnx.index(data = t(sphere$vb[-4,
]), query = matrix(shared_dir, ncol = 3), k = noise_points)
shared_points = sphere$vb[1:3, closest_points_shared] *
1.35 + rnorm(1, mean = 0, sd = 0.1)
sphere1$vb[1:3, closest_points_shared] = shared_points
sphere2$vb[1:3, closest_points_shared] = shared_points
}
sphere_mesh1 = convert_off_file(sphere1)
sphere_mesh2 = convert_off_file(sphere2)
complex_points[[(2 * i - 1)]] = t(sphere1$vb[1:3, ])
complex_points[[2 * i]] = t(sphere2$vb[1:3, ])
shared_points_list[[i]] = shared_points
ec_curve_class1 <- matrix(NA, nrow = 1, ncol = 0)
ec_curve_class2 <- matrix(NA, nrow = 1, ncol = 0)
#    for (j in 1:dim(dir)[1]) {
#      vertex_function_class_1 <- sphere_mesh1$Vertices %*%
#        c(dir[j, 1], dir[j, 2], dir[j, 3])
#      vertex_function_class_2 <- sphere_mesh2$Vertices %*%
#        c(dir[j, 1], dir[j, 2], dir[j, 3])
curve1 = mesh_to_matrix(sphere1)
curve2 = mesh_to_matrix(sphere2)
print(length(curve1))
#if (ball == TRUE) {
#  curve1 <- compute_standardized_ec_curve(sphere_mesh1,
#                                          vertex_function_class_1, curve_length - 1,
#                                          first_column_index = FALSE, ball_radius)
#  curve2 <- compute_standardized_ec_curve(sphere_mesh2,
#                                          vertex_function_class_2, curve_length - 1,
#                                          first_column_index = FALSE, ball_radius)
#}
#else {
#  curve1 <- compute_discrete_ec_curve(sphere_mesh1,
#                                      vertex_function_class_1, curve_length - 1,
#                                      first_column_index = FALSE)
#  curve2 <- compute_discrete_ec_curve(sphere_mesh2,
#                                      vertex_function_class_2, curve_length - 1,
#                                      first_column_index = FALSE)
#}
#curve1 <- update_ec_curve(curve1, ec_type)
#curve2 <- update_ec_curve(curve2, ec_type)
#ec_curve_class1 <- c(ec_curve_class1, curve1[, 2])
#ec_curve_class2 <- c(ec_curve_class2, curve2[, 2])
ec_curve_class1 <- c(ec_curve_class1, curve1)
ec_curve_class2 <- c(ec_curve_class2, curve2)
print(length(ec_curve_class1))
#}
data <- rbind(data, c(1, ec_curve_class1))
data <- rbind(data, c(-1, ec_curve_class2))
}
data_list = list(data = data, noise = total_shared_points,
causal_points1 = total_closest_points_class1, causal_points2 = total_closest_points_class2,
complex_points = complex_points, shared_points_list = shared_points_list,
total_cusps_list = total_cusps_list, region_vertex_dict = region_vertex_dictionary,
vertex_region_dict = vertex_region_dictionary)
return(data_list)
}
m = mesh_to_matrix(mesh)
#### Test New Function ####
data2 = generate_data_sphere_simulation_new(nsim = nsim,dir = dirs, curve_length = len,noise_points = shared_points,
causal_points = causal_points,ball_radius = ball_radius, subdivision = subdivision,
cusps = cusps, causal_regions_1 = causal_regions_1, causal_regions_2 = causal_regions_2,
shared_regions = shared_regions, ec_type = ec_type)
lasso = cv.gglasso(x = data2$data[,-1], y = data2$data[,1], group = rep(1:(dim(data2$data)[2]/3),3))
lasso
coef  = coef(lasso)
coeof
library(gglasso)
#### Test New Function ####
data2 = generate_data_sphere_simulation_new(nsim = nsim,dir = dirs, curve_length = len,noise_points = shared_points,
causal_points = causal_points,ball_radius = ball_radius, subdivision = subdivision,
cusps = cusps, causal_regions_1 = causal_regions_1, causal_regions_2 = causal_regions_2,
shared_regions = shared_regions, ec_type = ec_type)
lasso = cv.gglasso(x = data2$data[,-1], y = data2$data[,1], group = rep(1:(dim(data2$data)[2]/3),3))
coefs  = coef(lasso)
coefs
which(coefs >0)
data2$causal_points1
data2$causal_points2
rep(1:20, each = 2)
lasso = cv.gglasso(x = data2$data[,-1], y = data2$data[,1], group = rep(1:(dim(data2$data)[2]/3),3), loss = "logit")
coefs  = coef(lasso)
coefs
which(coefs > 0)
data2$data[,-1]
data2$data[,-1][,1]
coefs  = coef(lasso, s = 'lambda.min')
coefs
which(coefs>0)
lasso = cv.gglasso(x = data2$data[,-1], y = data2$data[,1], group = rep(1:(dim(data2$data)[2]/3),3), loss = "logit", alpha = 0.5)
lasso = cv.gglasso(x = data2$data[,-1], y = data2$data[,1], group = rep(1:(dim(data2$data)[2]/3),3), loss = "logit")
coefs  = coef(lasso, s = 'lambda.min')
which(coefs>0)
1670/3
1669/3
1/3
lasso$lambda.1se
lasso$lambda.min
#### Test New Function ####
library(glmnet)
install.packages('glmnet')
#### Test New Function ####
library(glmnet)
#lasso = cv.gglasso(x = data2$data[,-1], y = data2$data[,1], group = rep(1:(dim(data2$data)[2]/3),3), loss = "logit")
lasso = cv.gglasso(x = data2$data[,-1], y = data2$data[,1], alpha = 0.5,  loss = "logit")
#lasso = cv.gglasso(x = data2$data[,-1], y = data2$data[,1], group = rep(1:(dim(data2$data)[2]/3),3), loss = "logit")
lasso = cv.glmnet(x = data2$data[,-1], y = data2$data[,1], alpha = 0.5,  loss = "logit")
coefs  = coef(lasso, s = 'lambda.min')
which(coefs>0)
#lasso = cv.gglasso(x = data2$data[,-1], y = data2$data[,1], group = rep(1:(dim(data2$data)[2]/3),3), loss = "logit")
lasso = cv.glmnet(x = data2$data[,-1], y = data2$data[,1], alpha = 0.5,  family = "binomial")
coefs  = coef(lasso, s = 'lambda.min')
which(coefs>0)
groups = rep(1:(dim(data2$data)[2]/3),3)
groups
nonzero = which(coefs>0)
nonzero
groups[nonzero]
groups
groups
groups = rep(1:(dim(data2$data)[2]/3),3)
groups
groups = rep(1:(dim(data2$data)[2]/3),each = 3)
#lasso = cv.gglasso(x = data2$data[,-1], y = data2$data[,1], group = rep(1:(dim(data2$data)[2]/3),3), loss = "logit")
lasso = cv.glmnet(x = data2$data[,-1], y = data2$data[,1], alpha = 0.5,  family = "binomial")
coefs  = coef(lasso, s = 'lambda.min')
nonzero = which(coefs>0)
groups
groups[nonzero]
groups = rep(1:(dim(data2$data)[2]/3),each = 3)
lasso = cv.gglasso(x = data2$data[,-1], y = data2$data[,1], group = groups, loss = "logit")
#lasso = cv.glmnet(x = data2$data[,-1], y = data2$data[,1], alpha = 0.5,  family = "binomial")
coefs  = coef(lasso, s = 'lambda.min')
nonzero = which(coefs>0)
groups[nonzero]
nonzero
groups = rep(1:(dim(data2$data)[2]/3),each = 3)
#lasso = cv.gglasso(x = data2$data[,-1], y = data2$data[,1], group = groups, loss = "logit")
lasso = cv.glmnet(x = data2$data[,-1], y = data2$data[,1], alpha = 0.5,  family = "binomial")
coefs  = coef(lasso, s = 'lambda.min')
nonzero = which(coefs>0)
groups[nonzero]
unique(groups)
groups[nonzero]
unique(groups[nonzero])
results = unique(groups[nonzero])
mesh = vcgSphere(subdivision = 3)
mesh$vb[1:3,] = t(data2$complex_points[[1]])
cols = rep('white', dim(mesh$vb)[2])
cols[data$causal_points1] = 'red'
cols[data$noise] = 'blue'
cols[results] = 'green'
plot3d(mesh, col = cols)
lasso = cv.glmnet(x = data2$data[,-1], y = data2$data[,1], alpha = 0.0,  family = "binomial")
coefs  = coef(lasso, s = 'lambda.min')
nonzero = which(coefs>0)
results = unique(groups[nonzero])
mesh = vcgSphere(subdivision = 3)
mesh$vb[1:3,] = t(data2$complex_points[[1]])
cols = rep('white', dim(mesh$vb)[2])
cols[data$causal_points1] = 'red'
cols[data$noise] = 'blue'
cols[results] = 'green'
plot3d(mesh, col = cols)
nonzero = which(coefs>0.5)
results = unique(groups[nonzero])
nonzero = which(coefs>0.5)
results = unique(groups[nonzero])
mesh = vcgSphere(subdivision = 3)
mesh$vb[1:3,] = t(data2$complex_points[[1]])
cols = rep('white', dim(mesh$vb)[2])
cols[data$causal_points1] = 'red'
cols[data$noise] = 'blue'
cols[results] = 'green'
plot3d(mesh, col = cols)
which(coefs < 0)
nonzero = which(abs(coefs)>0.5)
results = unique(groups[nonzero])
mesh = vcgSphere(subdivision = 3)
mesh$vb[1:3,] = t(data2$complex_points[[1]])
cols = rep('white', dim(mesh$vb)[2])
cols[data$causal_points1] = 'red'
cols[data$noise] = 'blue'
cols[results] = 'green'
plot3d(mesh, col = cols)
lasso = cv.glmnet(x = data2$data[,-1], y = data2$data[,1], alpha = 0.0,  family = "binomial")
coefs  = coef(lasso, s = 'lambda.min')
nonzero = which(abs(coefs)>0.8)
results = unique(groups[nonzero])
mesh = vcgSphere(subdivision = 3)
mesh$vb[1:3,] = t(data2$complex_points[[1]])
cols = rep('white', dim(mesh$vb)[2])
cols[data$causal_points1] = 'red'
cols[data$noise] = 'blue'
cols[results] = 'green'
plot3d(mesh, col = cols)
merge(groups, coefs)
g = merge(matrix(groups), matrix(coefs))
g
g
matrix(groups)
matrix(coefs)
g = cbind(groups, coefs)
length(groups)
length(results)
length(coefs)
length(coefs)
coefs[0]
coefs
g = cbind(groups, coefs[-1])
g
coefs[1:10]
dim(data2$data[,-1])
#Binary Option
nonzero = which(abs(coefs[-1])>0.8)
results = unique(groups[nonzero])
mesh = vcgSphere(subdivision = 3)
mesh$vb[1:3,] = t(data2$complex_points[[1]])
cols = rep('white', dim(mesh$vb)[2])
cols[data$causal_points1] = 'red'
cols[data$noise] = 'blue'
cols[results] = 'green'
plot3d(mesh, col = cols)
mesh = vcgSphere(subdivision = 3)
mesh$vb[1:3,] = t(data2$complex_points[[1]])
cols = rep('white', dim(mesh$vb)[2])
cols[data$causal_points1] = 'red'
cols[data$causal_points1] = 'red'
cols[data$noise] = 'blue'
cols[results] = 'green'
plot3d(mesh, col = cols)
#### Sanity Checks ####
mesh = vcgSphere(subdivision = 3)
mesh$vb[1:3,] = t(data2$complex_points[[1]])
cols = rep('white', dim(mesh$vb)[2])
cols[data$causal_points1] = 'red'
cols[data$causal_points2] = 'red'
cols[data$noise] = 'blue'
cols[results] = 'green'
plot3d(mesh, col = cols)
#### Sanity Checks ####
color1='blue'
color2='lightgreen'
color3='red'
col_pal=c(color1,color1,color2,color2,color2,color3)
col_pal = c("#00007F", "blue", "#007FFF", "cyan",  "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")
colfunc <- colorRampPalette(col_pal)
new_heat_colors=colfunc(max(new_heat[,1]) - min(new_heat[,1]))[new_heat[,1] - min(new_heat[,1])]
colfunc <- colorRampPalette(col_pal)
heat_colors=colfunc(max(abs_coefs[,1]) - min(abs_coefs[,1]))[abs_coefs[,1] - min(abs_coefs[,1])]
abs_coefs = abs(coefs)
color1='blue'
color2='lightgreen'
color3='red'
col_pal=c(color1,color1,color2,color2,color2,color3)
col_pal = c("#00007F", "blue", "#007FFF", "cyan",  "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")
colfunc <- colorRampPalette(col_pal)
heat_colors=colfunc(max(abs_coefs[,1]) - min(abs_coefs[,1]))[abs_coefs[,1] - min(abs_coefs[,1])]
g = cbind(groups, coefs[-1])
g
which.max(g)
which.max(g[,1])
data.table(g)
library(data.table)
df = as.data.table(g)
df[,list(Name = Name[which.max(Value)]),by = GroupID]
df
df[,list(Name = Name[which.max(V2)]),by = groups]
df[,list(V2 = V2[which.max(V2)]),by = groups]
max(groups)
df[,list(V2 = V2[which.max(V2)]),by = groups]
df
abs_coefs = df[,list(V2 = V2[which.max(V2)]),by = groups][,2]
abs_coefs
abs_coefs = abs(df[,list(V2 = V2[which.max(V2)]),by = groups][,2])
color1='blue'
color2='lightgreen'
color3='red'
col_pal=c(color1,color1,color2,color2,color2,color3)
col_pal = c("#00007F", "blue", "#007FFF", "cyan",  "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")
colfunc <- colorRampPalette(col_pal)
heat_colors=colfunc(max(abs_coefs[,1]) - min(abs_coefs[,1]))[abs_coefs[,1] - min(abs_coefs[,1])]
abs_coefs
abs_coefs = as.vector(abs(df[,list(V2 = V2[which.max(V2)]),by = groups][,2]))
color1='blue'
color2='lightgreen'
color3='red'
col_pal=c(color1,color1,color2,color2,color2,color3)
col_pal = c("#00007F", "blue", "#007FFF", "cyan",  "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")
colfunc <- colorRampPalette(col_pal)
heat_colors=colfunc(max(abs_coefs[,1]) - min(abs_coefs[,1]))[abs_coefs[,1] - min(abs_coefs[,1])]
abs_coefs
abs_coefs[,1]
abs_coefs$V2
abs_coefs = abs(df[,list(V2 = V2[which.max(V2)]),by = groups][,2])$V2
color1='blue'
color2='lightgreen'
color3='red'
col_pal=c(color1,color1,color2,color2,color2,color3)
col_pal = c("#00007F", "blue", "#007FFF", "cyan",  "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")
colfunc <- colorRampPalette(col_pal)
heat_colors=colfunc(max(abs_coefs[,1]) - min(abs_coefs[,1]))[abs_coefs[,1] - min(abs_coefs[,1])]
heat_colors=colfunc(max(abs_coefs) - min(abs_coefs))[abs_coefs - min(abs_coefs)]
heat_colors
heat_colors=colfunc(max(abs_coefs) - min(abs_coefs))[abs_coefs - min(abs_coefs)]
plot3d(mesh, col = heat_colors)
heat_colors=colfunc(length(unique(abs_coefs)))[abs_coefs - min(abs_coefs)]
mesh = vcgSphere(subdivision = 3)
mesh$vb[1:3,] = t(data2$complex_points[[1]])
cols = rep('white', dim(mesh$vb)[2])
cols[data$causal_points1] = 'red'
cols[data$causal_points2] = 'red'
cols[data$noise] = 'blue'
cols[results] = 'green'
plot3d(mesh, col = cols)
plot3d(mesh, col = heat_colors)
#### Sanity Checks ####
abs_coefs
cuts = quantile(abs_coefs,100)
cuts = quantile(abs_coefs,probs = seq(1,0,100))
cuts = quantile(abs_coefs,probs = seq(1,0,length.out = 100))
cuuts
cuts
cuts = quantile(abs_coefs,probs = seq(1,0,length.out = 200))
xura
cuts
.bincode(abs_coefs,10)
cut(abs_coefs,10)
cut(abs_coefs,10, labels = FALSE)
cuts = cut(abs_coefs,100,labels = FALSE)
color1='blue'
color2='lightgreen'
color3='red'
col_pal=c(color1,color1,color2,color2,color2,color3)
col_pal = c("#00007F", "blue", "#007FFF", "cyan",  "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")
colfunc <- colorRampPalette(col_pal)
heat_colors=colfunc(max(cuts) - min(cuts))[cuts - min(cuts)]
plot3d(mesh, col = heat_colors)
col_pal=c(color1,color1,color2,color2,color2,color3)
colfunc <- colorRampPalette(col_pal)
heat_colors=colfunc(max(cuts) - min(cuts))[cuts - min(cuts)]
plot3d(mesh, col = heat_colors)
col_pal=c(color1,color2,color3)
#col_pal = c("#00007F", "blue", "#007FFF", "cyan",  "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")
col_pal=c(color1,color1,color2,color2,color2,color3)
colfunc <- colorRampPalette(col_pal)
heat_colors=colfunc(max(cuts) - min(cuts))[cuts - min(cuts)]
mesh = vcgSphere(subdivision = 3)
mesh$vb[1:3,] = t(data2$complex_points[[1]])
cols = rep('white', dim(mesh$vb)[2])
cols[data$causal_points1] = 'red'
cols[data$causal_points2] = 'red'
cols[data$noise] = 'blue'
cols[results] = 'green'
plot3d(mesh, col = cols)
plot3d(mesh, col = heat_colors)
#### Sanity Checks ####
hist(cuuts)
hist(cuts)
cuts = cut(log(abs_coefs),100,labels = FALSE)
color1='blue'
color2='lightgreen'
color3='red'
col_pal=c(color1,color2,color3)
#col_pal = c("#00007F", "blue", "#007FFF", "cyan",  "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")
col_pal=c(color1,color1,color2,color2,color2,color3)
colfunc <- colorRampPalette(col_pal)
heat_colors=colfunc(max(cuts) - min(cuts))[cuts - min(cuts)]
mesh = vcgSphere(subdivision = 3)
mesh$vb[1:3,] = t(data2$complex_points[[1]])
cols = rep('white', dim(mesh$vb)[2])
cols[data$causal_points1] = 'red'
cols[data$causal_points2] = 'red'
cols[data$noise] = 'blue'
cols[results] = 'green'
plot3d(mesh, col = cols)
plot3d(mesh, col = heat_colors)
log(cuts)
log(abs_coefs)
library(glmnet)
data2 = generate_data_sphere_simulation_new(nsim = nsim,dir = dirs, curve_length = len,noise_points = shared_points,
causal_points = causal_points,ball_radius = ball_radius, subdivision = subdivision,
cusps = cusps, causal_regions_1 = causal_regions_1, causal_regions_2 = causal_regions_2,
shared_regions = shared_regions, ec_type = ec_type)
groups = rep(1:(dim(data2$data)[2]/3),each = 3)
#lasso = cv.gglasso(x = data2$data[,-1], y = data2$data[,1], group = groups, loss = "logit")
lasso = cv.glmnet(x = data2$data[,-1], y = data2$data[,1], alpha = 0.0,  family = "binomial")
coefs  = coef(lasso, s = 'lambda.min')
#Binary Option
nonzero = which(abs(coefs[-1])>0.8)
results = unique(groups[nonzero])
# Heatmap Option
g = cbind(groups, coefs[-1])
library(data.table)
df = as.data.table(g)
abs_coefs = abs(df[,list(V2 = V2[which.max(V2)]),by = groups][,2])$V2
cuts = cut(abs_coefs,100,labels = FALSE)
color1='blue'
color2='lightgreen'
color3='red'
col_pal=c(color1,color2,color3)
#col_pal = c("#00007F", "blue", "#007FFF", "cyan",  "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")
col_pal=c(color1,color1,color2,color2,color2,color3)
colfunc <- colorRampPalette(col_pal)
heat_colors=colfunc(max(cuts) - min(cuts))[cuts - min(cuts)]
mesh = vcgSphere(subdivision = 3)
mesh$vb[1:3,] = t(data2$complex_points[[1]])
cols = rep('white', dim(mesh$vb)[2])
cols[data$causal_points1] = 'red'
cols[data$causal_points2] = 'red'
cols[data$noise] = 'blue'
cols[results] = 'green'
plot3d(mesh, col = cols)
plot3d(mesh, col = heat_colors)
col_pal=c(color1,color2,color3)
colfunc <- colorRampPalette(col_pal)
heat_colors=colfunc(max(cuts) - min(cuts))[cuts - min(cuts)]
mesh = vcgSphere(subdivision = 3)
mesh$vb[1:3,] = t(data2$complex_points[[1]])
cols = rep('white', dim(mesh$vb)[2])
cols[data$causal_points1] = 'red'
cols[data$causal_points2] = 'red'
cols[data$noise] = 'blue'
cols[results] = 'green'
plot3d(mesh, col = cols)
plot3d(mesh, col = heat_colors)
#### Sanity Checks ####
cuts
cuts = cut(abs_coefs,50,labels = FALSE)
color1='blue'
color2='lightgreen'
color3='red'
#col_pal = c("#00007F", "blue", "#007FFF", "cyan",  "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")
col_pal=c(color1,color1,color2,color2,color2,color3)
col_pal=c(color1,color2,color3)
colfunc <- colorRampPalette(col_pal)
heat_colors=colfunc(max(cuts) - min(cuts))[cuts - min(cuts)]
mesh = vcgSphere(subdivision = 3)
mesh$vb[1:3,] = t(data2$complex_points[[1]])
cols = rep('white', dim(mesh$vb)[2])
cols[data$causal_points1] = 'red'
cols[data$causal_points2] = 'red'
cols[data$noise] = 'blue'
cols[results] = 'green'
plot3d(mesh, col = cols)
plot3d(mesh, col = heat_colors)
#### Sanity Checks ####
abs_coefs = abs(df[,list(V2 = V2[which.max(abs(V2))]),by = groups][,2])$V2
cuts = cut(abs_coefs,50,labels = FALSE)
color1='blue'
color2='lightgreen'
color3='red'
#col_pal = c("#00007F", "blue", "#007FFF", "cyan",  "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")
col_pal=c(color1,color1,color2,color2,color2,color3)
col_pal=c(color1,color2,color3)
colfunc <- colorRampPalette(col_pal)
heat_colors=colfunc(max(cuts) - min(cuts))[cuts - min(cuts)]
plot3d(mesh, col = heat_colors)
g = cbind(groups, abs(coefs[-1]))
library(data.table)
df = as.data.table(g)
library(data.table)
df = as.data.table(g)
abs_coefs = abs(df[,list(V2 = V2[which.max(V2)]),by = groups][,2])$V2
cuts = cut(abs_coefs,50,labels = FALSE)
color1='blue'
color2='lightgreen'
color3='red'
#col_pal = c("#00007F", "blue", "#007FFF", "cyan",  "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")
col_pal=c(color1,color1,color2,color2,color2,color3)
col_pal=c(color1,color2,color3)
colfunc <- colorRampPalette(col_pal)
heat_colors=colfunc(max(cuts) - min(cuts))[cuts - min(cuts)]
mesh = vcgSphere(subdivision = 3)
mesh$vb[1:3,] = t(data2$complex_points[[1]])
cols = rep('white', dim(mesh$vb)[2])
cols[data$causal_points1] = 'red'
cols[data$causal_points2] = 'red'
cols[data$noise] = 'blue'
cols[results] = 'green'
plot3d(mesh, col = cols)
plot3d(mesh, col = heat_colors)
